{"task_id": "HumanEval/24", "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"Für eine gegebene Zahl n finden Sie die größte Zahl, die n gleichmäßig teilt und kleiner als n ist\n    >>> largest_divisor(15)\n    5\"\"\"\n", "entry_point": "largest_divisor", "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"}
{"task_id": "HumanEval/23", "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"Gib die Länge des gegebenen Strings zurück\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\"\"\"\n", "entry_point": "strlen", "canonical_solution": "    return len(string)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"}
{"task_id": "HumanEval/10", "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"Originaler Text: \"\"\"Überprüfen Sie, ob der angegebene String ein Palindrom ist\"\"\"\nÜbersetzung:\"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n", "entry_point": "make_palindrome", "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"}
{"task_id": "HumanEval/2", "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"Gegeben eine positive Zahl mit Fließkomma, kann sie in einen ganzzahligen Teil (größte ganze Zahl, die kleiner als die gegebene Zahl ist) und Nachkommastellen (restlicher Teil, der immer kleiner als 1 ist) zerlegt werden.\n\nGeben Sie den Dezimalteil der Zahl zurück.\n>>> truncate_number(3.5)\n0.5\"\"\"\n", "entry_point": "truncate_number", "canonical_solution": "    return number % 1.0\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"}
{"task_id": "HumanEval/14", "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"Geben Sie eine Liste aller Präfixe vom kürzesten bis zum längsten des Eingabestrings zurück \n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\"\"\"\n", "entry_point": "all_prefixes", "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"}
{"task_id": "HumanEval/16", "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"Gegeben eine Zeichenkette, finde heraus, aus wie vielen verschiedenen Zeichen (ohne Beachtung der Groß-/Kleinschreibung) sie besteht.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\"\"\"\n", "entry_point": "count_distinct_characters", "canonical_solution": "    return len(set(string.lower()))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"}
{"task_id": "HumanEval/7", "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"Filtern Sie eine Eingabeliste von Zeichenketten nur nach solchen, die einen bestimmten Teilstring enthalten\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n", "entry_point": "filter_by_substring", "canonical_solution": "    return [x for x in strings if substring in x]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"}
{"task_id": "HumanEval/9", "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"Aus einer gegebenen Liste von Ganzzahlen generieren Sie eine Liste der rollierenden Maximalwerte, die bis zu diesem Zeitpunkt in der Sequenz gefunden wurden.\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\"\"\"\n", "entry_point": "rolling_max", "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"}
{"task_id": "HumanEval/18", "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"Ermitteln Sie, wie oft eine gegebene Teilzeichenkette in der Originalzeichenkette gefunden werden kann. Zählen Sie überlappende Fälle.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\"\"\"\n", "entry_point": "how_many_times", "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"}
{"task_id": "HumanEval/5", "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"Setzen Sie eine Zahl 'Trennzeichen' zwischen jedes zwei aufeinanderfolgende Elemente der Eingabeliste 'Zahlen'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n", "entry_point": "intersperse", "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"}
{"task_id": "HumanEval/11", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"Die Eingabe sind zwei Zeichenketten a und b, die nur aus den Zahlen 1 und 0 bestehen.\nFühre eine binäre Exklusiv-Oder-Operation auf diesen Eingaben aus und gib das Ergebnis auch als Zeichenkette zurück.\n>>> string_xor('010', '110')\n'100'\"\"\"\n", "entry_point": "string_xor", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"}
{"task_id": "HumanEval/8", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"Für eine gegebene Liste von Ganzzahlen geben Sie ein Tupel zurück, das aus einer Summe und einem Produkt aller Ganzzahlen in der Liste besteht.\nEine leere Summe sollte gleich 0 sein und ein leeres Produkt sollte gleich 1 sein.\n>>> sum_product([])\n(0, 1)\n>>> sum_product([1, 2, 3, 4])\n(10, 24)\"\"\"\n", "entry_point": "sum_product", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"}
{"task_id": "HumanEval/0", "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\"\"\"\n", "entry_point": "has_close_elements", "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"}
{"task_id": "HumanEval/13", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"Geben Sie den größten gemeinsamen Teiler von zwei ganzen Zahlen a und b zurück\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\"\"\"\n", "entry_point": "greatest_common_divisor", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"}
{"task_id": "HumanEval/6", "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"Die Eingabe für diese Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern durch Leerzeichen getrennt darstellt.\nFür jede Gruppe soll die tiefste Verschachtelungsebene der Klammern ausgegeben werden.\nZum Beispiel hat '(()())' eine maximale Verschachtelung von zwei Ebenen, während '((()))' drei Ebenen hat.\n\n>>> parse_nested_parens('(()()) ((())) () ((())()())')\n[2, 3, 1, 3]\n\"\"\"\n", "entry_point": "parse_nested_parens", "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"}
{"task_id": "HumanEval/22", "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"Filtern Sie die gegebene Liste von beliebigen Python-Werten nur für ganze Zahlen\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\"\"\"\n", "entry_point": "filter_integers", "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"}
{"task_id": "HumanEval/4", "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Für eine gegebene Liste von Eingabezahlen berechnen Sie die mittlere absolute Abweichung\n    um den Mittelwert dieses Datensatzes.\n    Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem\n    Element und einem Mittelpunkt (in diesem Fall der Mittelwert):\n    MAD = Durchschnitt | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\"\"\"\n", "entry_point": "mean_absolute_deviation", "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n"}
{"task_id": "HumanEval/3", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"Sie erhalten eine Liste von Einzahlungs- und Auszahlungsvorgängen auf einem Bankkonto, das mit einem Kontostand von null beginnt. Ihre Aufgabe ist es festzustellen, ob zu irgendeinem Zeitpunkt der Kontostand unter null fällt, und an diesem Punkt sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue\"\"\"\n", "entry_point": "below_zero", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"}
{"task_id": "HumanEval/15", "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"Geben Sie einen String zurück, der Zahlen enthält, die mit Leerzeichen getrennt sind und von 0 bis n einschließlich gehen.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\"\"\"\n", "entry_point": "string_sequence", "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"}
{"task_id": "HumanEval/12", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"Aus der Liste der Zeichenketten die längste zurückgeben. Geben Sie die erste zurück, wenn es mehrere Zeichenketten gleicher Länge gibt. Geben Sie None zurück, wenn die Eingabeliste leer ist.\nlongest([])\n\nlongest(['a', 'b', 'c'])\n'a'\nlongest(['a', 'bb', 'ccc'])\n'ccc'\"\"\"\n", "entry_point": "longest", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"}
{"task_id": "HumanEval/19", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"Eingabe ist ein durch Leerzeichen getrennter String von Zahlen von 'zero' bis 'nine'.\n    Gültige Auswahlmöglichkeiten sind 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' und 'nine'.\n    Gib den String mit Zahlen zurück, der von kleinster bis größter sortiert ist.\n    >>> sort_numbers('three one five')\n    'one three five'\"\"\"\n", "entry_point": "sort_numbers", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"}
{"task_id": "HumanEval/1", "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"Die Eingabe für diese Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es, diese Gruppen in separate Strings zu trennen und die Liste derer zurückzugeben. Separate Gruppen sind ausgewogen (jede öffnende Klammer ist ordnungsgemäß geschlossen) und nicht ineinander verschachtelt. Leerzeichen in dem Eingabe-String werden ignoriert.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']\"\"\"\n", "entry_point": "separate_paren_groups", "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"}
{"task_id": "HumanEval/20", "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"Von einer bereitgestellten Liste von Zahlen (mindestens zwei Zahlen) wählen Sie zwei Zahlen aus, die einander am nächsten liegen, und geben Sie sie in aufsteigender Reihenfolge zurück (kleinere Zahl, größere Zahl).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\"\"\"\n", "entry_point": "find_closest_elements", "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"}
{"task_id": "HumanEval/21", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Gegebene Liste von Zahlen (mit mindestens zwei Elementen), wenden Sie eine lineare Transformation auf diese Liste an, so dass die kleinste Zahl 0 wird und die größte Zahl 1 wird\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\"\"\"\n", "entry_point": "rescale_to_unit", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"}
{"task_id": "HumanEval/17", "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"Die Eingabe für diese Funktion ist ein String, der musikalische Noten in einem speziellen ASCII-Format darstellt. Ihre Aufgabe ist es, diesen String zu analysieren und eine Liste von ganzen Zahlen zurückzugeben, die angeben, wie viele Schläge jede Note dauert.\n\nHier ist eine Legende:\n'o' - Ganze Note, dauert vier Schläge\n'o|' - Halbe Note, dauert zwei Schläge\n'.|' - Viertelnote, dauert ein Schlag\n\n>>> parse_music('o o| .| o| o| .| .| .| .| o o')\n[4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\"\"\"\n", "entry_point": "parse_music", "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"}
{"task_id": "HumanEval/25", "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"Gib eine Liste der Primfaktoren der gegebenen ganzen Zahl in aufsteigender Reihenfolge zurück.\nJeder der Faktoren sollte entsprechend der Anzahl, wie oft er in der Faktorisierung vorkommt, aufgelistet sein.\nDie Eingabezahl sollte gleich dem Produkt aller Faktoren sein.\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\"\"\"\n", "entry_point": "factorize", "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"}
{"task_id": "HumanEval/38", "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"gibt den codierten String zurück, indem Gruppen von drei Zeichen durchlaufen werden.\"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n", "entry_point": "decode_cyclic", "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"}
{"task_id": "HumanEval/64", "prompt": "\nFIX = \"\"\"Fügen Sie weitere Testfälle hinzu.\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/138", "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Überprüfen Sie, ob die gegebene Zahl n als Summe genau von 4 positiven geraden Zahlen geschrieben werden kann.\nBeispiel\nis_equal_to_sum_even(4) == Falsch\nis_equal_to_sum_even(6) == Falsch\nis_equal_to_sum_even(8) == Wahr\"\"\"\n", "entry_point": "is_equal_to_sum_even", "canonical_solution": "    return n%2 == 0 and n >= 8\n", "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"}
{"task_id": "HumanEval/28", "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Verketten Sie eine Liste von Zeichenketten zu einer einzigen Zeichenkette\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\"\"\"\n", "entry_point": "concatenate", "canonical_solution": "    return ''.join(strings)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"}
{"task_id": "HumanEval/50", "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"liefert eine codierte Zeichenkette, indem jeder Buchstabe im Alphabet um 5 verschoben wird.\"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n", "entry_point": "decode_shift", "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"}
{"task_id": "HumanEval/83", "prompt": "\ndef starts_one_ends(n):\n    \"\"\"Gegeben eine positive ganze Zahl n, geben Sie die Anzahl der Zahlen der n-stelligen positiven Ganzzahlen zurück, die mit 1 beginnen oder enden.\"\"\"\n", "entry_point": "starts_one_ends", "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/85", "prompt": "\ndef add(lst):\n    \"\"\"Gegeben ist eine nicht-leere Liste von ganzen Zahlen lst. Fügen Sie die geraden Elemente hinzu, die an ungeraden Indizes stehen.\n\n\n    Beispiele:\n        add([4, 2, 6, 7]) ==> 2\"\"\"\n", "entry_point": "add", "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"}
{"task_id": "HumanEval/27", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"Für einen gegebenen String werden kleine Buchstaben in Großbuchstaben umgewandelt und Großbuchstaben in kleine Buchstaben umgewandelt.\n    >>> flip_case('Hello')\n    'hELLO'\"\"\"\n", "entry_point": "flip_case", "canonical_solution": "    return string.swapcase()\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"}
{"task_id": "HumanEval/45", "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"Gegebene Länge einer Seite und Höhe geben Fläche für ein Dreieck zurück.\n    >>> triangle_area(5, 3)\n    7,5\"\"\"\n", "entry_point": "triangle_area", "canonical_solution": "    return a * h / 2.0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"}
{"task_id": "HumanEval/34", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Gib sortierte eindeutige Elemente in einer Liste zurück.\n    >>> eindeutig([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\"\"\"\n", "entry_point": "unique", "canonical_solution": "    return sorted(list(set(l)))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"}
{"task_id": "HumanEval/35", "prompt": "\n\ndef max_element(l: list):\n    \"\"\"Rückgabe des maximalen Elements in der Liste.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n", "entry_point": "max_element", "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"}
{"task_id": "HumanEval/53", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Füge zwei Zahlen x und y hinzu\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n", "entry_point": "add", "canonical_solution": "    return x + y\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"}
{"task_id": "HumanEval/75", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Schreiben Sie eine Funktion, die true zurückgibt, wenn die gegebene Zahl das Produkt aus 3 Primzahlen ist, andernfalls false.\n    Wissen, dass (a) kleiner als 100 ist.\n    Beispiel:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\"\"\"\n", "entry_point": "is_multiply_prime", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"}
{"task_id": "HumanEval/49", "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"Rückgabe von 2^n modulo p (Achtung auf Zahlen).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\"\"\"\n", "entry_point": "modp", "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"}
{"task_id": "HumanEval/61", "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"Klammern ist eine Zeichenfolge aus \"(\" und \")\".\nRückgabe True, wenn jede öffnende Klammer eine entsprechende schließende Klammer hat.\n\n>>> correct_bracketing(\"(\")\nFalse\n>>> correct_bracketing(\"()\")\nTrue\n>>> correct_bracketing(\"(()())\")\nTrue\n>>> correct_bracketing(\")(()\")\nFalse\n\"\"\"\n", "entry_point": "correct_bracketing", "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"}
{"task_id": "HumanEval/121", "prompt": "\ndef solution(lst):\n    \"\"\"Gegeben eine nicht leere Liste von Ganzzahlen, geben Sie die Summe aller ungeraden Elemente zurück, die sich an geraden Positionen befinden.\n\nBeispiele\nLösung([5, 8, 7, 1]) ==> 12\nLösung([3, 3, 3, 3, 3]) ==> 9\nLösung([30, 13, 24, 321]) ==> 0\"\"\"\n", "entry_point": "solution", "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"}
{"task_id": "HumanEval/55", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Rückgabe der n-ten Fibonacci-Zahl.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n", "entry_point": "fib", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"}
{"task_id": "HumanEval/32", "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"Evaluiert das Polynom mit Koeffizienten xs an der Stelle x.\nGib xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n zurück.\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n", "entry_point": "find_zero", "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"}
{"task_id": "HumanEval/57", "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"Gibt True zurück, wenn die Elemente der Liste monoton steigend oder fallend sind.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n", "entry_point": "monotonic", "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"}
{"task_id": "HumanEval/56", "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"Klammern ist ein String aus \"<\" und \">\".\nGib True zurück, wenn jede öffnende Klammer eine entsprechende schließende Klammer hat.\n\n>>> correct_bracketing(\"<\")\nFalse\n>>> correct_bracketing(\"<>\")\nTrue\n>>> correct_bracketing(\"<<><>>\")\nTrue\n>>> correct_bracketing(\"><<>\")\nFalse\n\"\"\"\n", "entry_point": "correct_bracketing", "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"}
{"task_id": "HumanEval/47", "prompt": "\n\ndef median(l: list):\n    \"\"\"Gibt den Median der Elemente in der Liste l zurück.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n", "entry_point": "median", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"}
{"task_id": "HumanEval/60", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"Die Funktion \"sum_to_n\" summiert Zahlen von 1 bis n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\"\"\"\n", "entry_point": "sum_to_n", "canonical_solution": "    return sum(range(n + 1))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"}
{"task_id": "HumanEval/65", "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"Verschieben Sie die Ziffern der Ganzzahl x zyklisch, verschieben Sie die Ziffern nach rechts um shift und geben Sie das Ergebnis als Zeichenkette zurück. Wenn shift > Anzahl der Ziffern, dann geben Sie die Ziffern in umgekehrter Reihenfolge zurück.\"\"\"\n", "entry_point": "circular_shift", "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/44", "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"Ändere die numerische Basis der Eingangsnummer x zur gegebenen Basis.\nGib die Zeichenkettendarstellung nach der Konvertierung zurück.\nDie Basiszahlen sind kleiner als 10.\n>>> change_base(8, 3)\n'22'\n>>> change_base(8, 2)\n'1000'\n>>> change_base(7, 2)\n'111'\"\"\"\n", "entry_point": "change_base", "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"}
{"task_id": "HumanEval/29", "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"Filtern Sie eine Eingabeliste von Zeichenketten nur nach solchen, die mit einem bestimmten Präfix beginnen.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n", "entry_point": "filter_by_prefix", "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"}
{"task_id": "HumanEval/108", "prompt": "\ndef count_nums(arr):\n    \"\"\"Schreiben Sie eine Funktion count_nums, die ein Array von Ganzzahlen entgegennimmt und die Anzahl der Elemente zurückgibt, deren Ziffernsumme > 0 ist. Wenn eine Zahl negativ ist, wird ihre erste vorzeichenbehaftete Ziffer negativ sein: z.B. -123 hat die vorzeichenbehafteten Ziffern -1, 2 und 3.\n>>> count_nums([]) == 0\n>>> count_nums([-1, 11, -11]) == 1\n>>> count_nums([1, 1, 2]) == 3\"\"\"\n", "entry_point": "count_nums", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/104", "prompt": "\ndef unique_digits(x):\n    \"\"\"Gegeben ist eine Liste von positiven ganzen Zahlen x. Gib eine sortierte Liste aller Elemente zurück, die keine gerade Ziffer enthalten.\n\nHinweis: Die zurückgegebene Liste sollte in aufsteigender Reihenfolge sortiert sein.\n\nBeispiel:\n>>> unique_digits([15, 33, 1422, 1])\n[1, 15, 33]\n>>> unique_digits([152, 323, 1422, 10])\n[]\"\"\"\n", "entry_point": "unique_digits", "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/48", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"Überprüft, ob der gegebene String ein Palindrom ist\n>>> ist_palindrom('')\nTrue\n>>> ist_palindrom('aba')\nTrue\n>>> ist_palindrom('aaaaa')\nTrue\n>>> ist_palindrom('zbcd')\nFalse\"\"\"\n", "entry_point": "is_palindrome", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"}
{"task_id": "HumanEval/139", "prompt": "\ndef special_factorial(n):\n    \"\"\"Der brasilianische Faktor ist wie folgt definiert:\n    brazilianischer_Faktor(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    wobei n > 0\n\n    Zum Beispiel:\n    >>> special_factorial(4)\n    288\n\n    Die Funktion erhält eine Ganzzahl als Eingabe und sollte den speziellen Faktor dieses Ganzzahls zurückgeben.\"\"\"\n", "entry_point": "special_factorial", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"}
{"task_id": "HumanEval/26", "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"Aus einer Liste von Ganzzahlen entfernen Sie alle Elemente, die mehr als einmal vorkommen.\nDie Reihenfolge der verbleibenden Elemente soll dieselbe sein wie in der Eingabe.\n>>> remove_duplicates([1, 2, 3, 2, 4])\n[1, 3, 4]\"\"\"\n", "entry_point": "remove_duplicates", "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"}
{"task_id": "HumanEval/31", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Gib \"wahr\" zurück, wenn eine gegebene Zahl eine Primzahl ist, ansonsten gib \"falsch\" zurück.\n>>> is_prime(6)\nfalsch\n>>> is_prime(101)\nwahr\n>>> is_prime(11)\nwahr\n>>> is_prime(13441)\nwahr\n>>> is_prime(61)\nwahr\n>>> is_prime(4)\nfalsch\n>>> is_prime(1)\nfalsch\"\"\"\n", "entry_point": "is_prime", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"}
{"task_id": "HumanEval/51", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels ist eine Funktion, die einen String entgegennimmt und einen String ohne Vokale zurückgibt.\n>>> remove_vowels('')\n''\n>>> remove_vowels(\"abcdef\\nghijklm\")\n'bcdf\\nghjklm'\n>>> remove_vowels('abcdef')\n'bcdf'\n>>> remove_vowels('aaaaa')\n''\n>>> remove_vowels('aaBAA')\n'B'\n>>> remove_vowels('zbcd')\n'zbcd'\"\"\"\n", "entry_point": "remove_vowels", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"}
{"task_id": "HumanEval/102", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Diese Funktion nimmt zwei positive Zahlen x und y entgegen und gibt die größte gerade ganze Zahl zurück, die im Bereich [x, y] eingeschlossen ist. Wenn es keine solche Zahl gibt, sollte die Funktion -1 zurückgeben.\n\nBeispiel:\nchoose_num(12, 15) = 14\nchoose_num(13, 12) = -1\"\"\"\n", "entry_point": "choose_num", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"}
{"task_id": "HumanEval/42", "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"Geben Sie die Liste mit um 1 erhöhten Elementen zurück.\n>>> incr_list([1, 2, 3])\n[2, 3, 4]\n>>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[6, 4, 6, 3, 4, 4, 10, 1, 124]\"\"\"\n", "entry_point": "incr_list", "canonical_solution": "    return [(e + 1) for e in l]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"}
{"task_id": "HumanEval/131", "prompt": "\ndef digits(n):\n    \"\"\"Gegeben eine positive Ganzzahl n, gib das Produkt der ungeraden Ziffern zurück.\nGib 0 zurück, wenn alle Ziffern gerade sind.\nZum Beispiel:\ndigits(1)  == 1\ndigits(4)  == 0\ndigits(235) == 15\"\"\"\n", "entry_point": "digits", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"}
{"task_id": "HumanEval/62", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"Die folgenden sind die Koeffizienten eines Polynoms.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Gib die Ableitung dieses Polynoms in der gleichen Form zurück.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\"\"\"\n", "entry_point": "derivative", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"}
{"task_id": "HumanEval/97", "prompt": "\ndef multiply(a, b):\n    \"\"\"Vervollständige die Funktion, die zwei Ganzzahlen entgegennimmt und das Produkt ihrer Einserstellen zurückgibt. Gehen Sie davon aus, dass die Eingabe immer gültig ist.\nBeispiele:\nmultiply(148, 412) sollte 16 zurückgeben.\nmultiply(19, 28) sollte 72 zurückgeben.\nmultiply(2020, 1851) sollte 0 zurückgeben.\nmultiply(14,-15) sollte 20 zurückgeben.\"\"\"\n", "entry_point": "multiply", "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"}
{"task_id": "HumanEval/135", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Erstellen Sie eine Funktion, die den größten Index eines Elements zurückgibt, das nicht größer oder gleich dem unmittelbar vorangehenden Element ist. Wenn kein solches Element existiert, geben Sie -1 zurück. Das gegebene Array enthält keine duplizierten Werte.\n\nBeispiele:\ncan_arrange([1,2,4,3,5]) = 3\ncan_arrange([1,2,3]) = -1\"\"\"\n", "entry_point": "can_arrange", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"}
{"task_id": "HumanEval/82", "prompt": "\ndef prime_length(string):\n    \"\"\"Schreiben Sie eine Funktion, die einen String entgegennimmt und True zurückgibt, wenn die Länge des Strings eine Primzahl ist, andernfalls False.\nBeispiele\nprime_length('Hello') == True\nprime_length('abcdcba') == True\nprime_length('kittens') == True\nprime_length('orange') == False\"\"\"\n", "entry_point": "prime_length", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"}
{"task_id": "HumanEval/100", "prompt": "\ndef make_a_pile(n):\n    \"\"\"Gegeben eine positive ganze Zahl n, du musst einen Stapel mit n Ebenen von Steinen machen. Die erste Ebene hat n Steine. Die Anzahl der Steine in der nächsten Ebene ist: - die nächste ungerade Zahl, wenn n ungerade ist. - die nächste gerade Zahl, wenn n gerade ist. Gib die Anzahl der Steine in jeder Ebene als Liste zurück, wobei das Element an der Stelle i die Anzahl der Steine in der Ebene (i+1) repräsentiert. Beispiele: make_a_pile(3) [3, 5, 7]\"\"\"\n", "entry_point": "make_a_pile", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/79", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Du erhältst eine Zahl in Dezimalform und deine Aufgabe ist es, diese in das Binärformat umzuwandeln. Die Funktion sollte einen String zurückgeben, wobei jedes Zeichen eine binäre Zahl repräsentiert. Jedes Zeichen im String wird entweder '0' oder '1' sein.\n\nAm Anfang und Ende des Strings wird es ein zusätzliches Zeichenpaar 'db' geben. Die zusätzlichen Zeichen dienen dazu, das Format zu erleichtern.\n\nBeispiele:\ndecimal_to_binary(15)   # gibt \"db1111db\" zurück\ndecimal_to_binary(32)   # gibt \"db100000db\" zurück\"\"\"\n", "entry_point": "decimal_to_binary", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/54", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"Überprüfen Sie, ob zwei Wörter die gleichen Zeichen enthalten.\n>>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\nTrue\n>>> same_chars('abcd', 'dddddddabc')\nTrue\n>>> same_chars('dddddddabc', 'abcd')\nTrue\n>>> same_chars('eabcd', 'dddddddabc')\nFalse\n>>> same_chars('abcd', 'dddddddabce')\nFalse\n>>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\nFalse\"\"\"\n", "entry_point": "same_chars", "canonical_solution": "    return set(s0) == set(s1)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"}
{"task_id": "HumanEval/84", "prompt": "\ndef solve(N):\n    \"\"\"Gegeben eine positive Ganzzahl N, gibt die Summe aller Ziffern in binärer Darstellung zurück.\n\n    Beispiel:\n        Für N = 1000, ist die Summe der Ziffern 1. Die Ausgabe sollte \"1\" sein.\n        Für N = 150, ist die Summe der Ziffern 6. Die Ausgabe sollte \"110\" sein.\n        Für N = 147, ist die Summe der Ziffern 12. Die Ausgabe sollte \"1100\" sein.\n\n    Variablen:\n        @N Ganzzahl\n             Einschränkungen: 0 ≤ N ≤ 10000.\n    Ausgabe:\n         eine Zeichenkette mit der binären Zahl.\"\"\"\n", "entry_point": "solve", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"}
{"task_id": "HumanEval/59", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Geben Sie den größten Primfaktor von n zurück. Nehmen Sie an, dass n > 1 und keine Primzahl ist.\n    >>> größten_primfaktor(13195)\n    29\n    >>> größten_primfaktor(2048)\n    2\"\"\"\n", "entry_point": "largest_prime_factor", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"}
{"task_id": "HumanEval/98", "prompt": "\ndef count_upper(s):\n    \"\"\"Gegeben ist ein String s, zähle die Anzahl der Großbuchstaben-Vokale an geraden Indizes.\n\nZum Beispiel:\ncount_upper('aBCdEf') gibt 1 zurück\ncount_upper('abcdefg') gibt 0 zurück\ncount_upper('dBBE') gibt 0 zurück\"\"\"\n", "entry_point": "count_upper", "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/90", "prompt": "\ndef next_smallest(lst):\n    \"\"\"Sie erhalten eine Liste von Ganzzahlen.\nSchreiben Sie eine Funktion next_smallest(), die das zweitkleinste Element der Liste zurückgibt.\nGeben Sie None zurück, wenn es kein solches Element gibt.\n\nnext_smallest([1, 2, 3, 4, 5]) == 2\nnext_smallest([5, 1, 4, 3, 2]) == 2\nnext_smallest([]) == None\nnext_smallest([1, 1]) == None\"\"\"\n", "entry_point": "next_smallest", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/111", "prompt": "\ndef histogram(test):\n    \"\"\"Gegeben eine Zeichenkette, die aus Leerzeichen separierte Kleinbuchstaben darstellt, gibt ein Wörterbuch zurück, das den Buchstaben mit den meisten Wiederholungen und die entsprechende Anzahl enthält. Wenn mehrere Buchstaben die gleiche Anzahl haben, gib alle von ihnen zurück.\n\nBeispiel:\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('a b c a b') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\"\"\"\n", "entry_point": "histogram", "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/52", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Gibt True zurück, wenn alle Zahlen in der Liste l unterhalb des Schwellenwerts t liegen.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\"\"\"\n", "entry_point": "below_threshold", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"}
{"task_id": "HumanEval/58", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Geben Sie sortierte, eindeutige gemeinsame Elemente für zwei Listen zurück.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"}
{"task_id": "HumanEval/66", "prompt": "\ndef digitSum(s):\n    \"\"\"Aufgabe\nSchreiben Sie eine Funktion, die einen String als Eingabe nimmt und die Summe der ASCII-Codes der Großbuchstaben zurückgibt.\n\nBeispiele:\ndigitSum(\"\") => 0\ndigitSum(\"abAB\") => 131\ndigitSum(\"abcCd\") => 67\ndigitSum(\"helloE\") => 69\ndigitSum(\"woArBld\") => 131\ndigitSum(\"aAaaaXa\") => 153\"\"\"\n", "entry_point": "digitSum", "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"}
{"task_id": "HumanEval/37", "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"Diese Funktion nimmt eine Liste l entgegen und gibt eine Liste l' zurück, bei der\nl' in den ungeraden Indizes identisch zu l ist, während die Werte an den geraden Indizes gleich\nden Werten der geraden Indizes von l sind, jedoch sortiert.\n>>> sort_even([1, 2, 3])\n[1, 2, 3]\n>>> sort_even([5, 6, 3, 4])\n[3, 6, 5, 4]\"\"\"\n", "entry_point": "sort_even", "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"}
{"task_id": "HumanEval/114", "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"Gegeben ein Array von ganzen Zahlen nums, finde die minimale Summe eines nicht-leeren Teil-Arrays von nums.\nBeispiel\nminSubArraySum([2, 3, 4, 1, 2, 4]) == 1\nminSubArraySum([-1, -2, -3]) == -6\"\"\"\n", "entry_point": "minSubArraySum", "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"}
{"task_id": "HumanEval/118", "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"Sie erhalten ein Wort. Ihre Aufgabe besteht darin, das nächstgelegene Vokal zu finden, das zwischen zwei Konsonanten auf der rechten Seite des Wortes steht (Groß- und Kleinschreibung beachten).\n\nVokale am Anfang und Ende zählen nicht. Geben Sie eine leere Zeichenkette zurück, wenn Sie keinen Vokal finden, der die obige Bedingung erfüllt.\n\nSie können davon ausgehen, dass der gegebene String nur englische Buchstaben enthält.\n\nBeispiel:\nget_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\"\n", "entry_point": "get_closest_vowel", "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/113", "prompt": "\ndef odd_count(lst):\n    \"\"\"Gegeben eine Liste von Zeichenketten, in denen jede Zeichenkette nur aus Ziffern besteht, gib eine Liste zurück. Jedes Element i der Ausgabe sollte \"die Anzahl der ungeraden Elemente in der i-ten Zeichenkette der Eingabe\" sein, wobei alle i durch die Anzahl der ungeraden Ziffern in der i-ten Zeichenkette der Eingabe ersetzt werden.\n\n>>> odd_count(['1234567'])\n[\"die Anzahl der ungeraden Elemente 4n der Str4ng 4 der 4nput.\"]\n>>> odd_count(['3',\"11111111\"])\n[\"die Anzahl der ungeraden Elemente 1n der Str1ng 1 der 1nput.\",\n \"die Anzahl der ungeraden Elemente 8n der Str8ng 8 der 8nput.\"]\"\"\"\n", "entry_point": "odd_count", "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/93", "prompt": "\ndef encode(message):\n    \"\"\"Schreiben Sie eine Funktion, die eine Nachricht entgegennimmt und diese codiert, indem sie den Fall aller Buchstaben tauscht und alle Vokale in der Nachricht durch den Buchstaben ersetzt, der 2 Plätze weiter im englischen Alphabet steht. Gehen Sie davon aus, dass es sich nur um Buchstaben handelt.\n\nBeispiele:\n>>> encode('test')\n'TGST'\n>>> encode('This is a message')\n'tHKS KS C MGSSCGG'\"\"\"\n", "entry_point": "encode", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/140", "prompt": "\ndef fix_spaces(text):\n    \"\"\"Gegeben einen String text, ersetze alle Leerzeichen darin durch Unterstriche,  und wenn ein String mehr als 2 aufeinanderfolgende Leerzeichen hat,  dann ersetze alle aufeinanderfolgenden Leerzeichen durch -.   \n\nfix_spaces(\"Beispiel\") == \"Beispiel\"\nfix_spaces(\"Beispiel 1\") == \"Beispiel_1\"\nfix_spaces(\" Beispiel 2\") == \"_Beispiel_2\"\nfix_spaces(\" Beispiel   3\") == \"_Beispiel-3\"\"\"\n", "entry_point": "fix_spaces", "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"}
{"task_id": "HumanEval/36", "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"Geben Sie die Anzahl der Male zurück, in denen die Ziffer 7 in ganzen Zahlen kleiner als n vorkommt, die durch 11 oder 13 teilbar sind.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n", "entry_point": "fizz_buzz", "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"}
{"task_id": "HumanEval/73", "prompt": "\ndef smallest_change(arr):\n    \"\"\"Gegeben ein Array arr von Ganzzahlen, finde die minimale Anzahl von Elementen, die geändert werden müssen, um das Array palindromisch zu machen. Ein palindromisches Array ist ein Array, das rückwärts und vorwärts gleich gelesen wird. In einer Änderung kannst du ein Element zu einem anderen Element ändern.\n\nZum Beispiel:\nkleinste_änderung([1,2,3,5,4,7,9,6]) == 4\nkleinste_änderung([1, 2, 3, 4, 3, 2, 2]) == 1\nkleinste_änderung([1, 2, 3, 2, 1]) == 0\"\"\"\n", "entry_point": "smallest_change", "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"}
{"task_id": "HumanEval/91", "prompt": "\ndef is_bored(S):\n    \"\"\"Dir wird eine Zeichenkette von Wörtern gegeben, und deine Aufgabe ist es, die Anzahl der Langweiligen zu zählen. Eine Langeweile ist ein Satz, der mit dem Wort \"Ich\" beginnt. Sätze werden durch '.', '?' oder '!' begrenzt.\n\nZum Beispiel:\n>>> is_bored(\"Hallo Welt\")\n0\n>>> is_bored(\"Der Himmel ist blau. Die Sonne scheint. Ich liebe dieses Wetter\")\n1\"\"\"\n", "entry_point": "is_bored", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/96", "prompt": "\ndef count_up_to(n):\n    \"\"\"Implementieren Sie eine Funktion, die eine nicht-negative ganze Zahl entgegennimmt und ein Array der ersten n Primzahlen zurückgibt, die kleiner als n sind.\nzum Beispiel:\ncount_up_to(5) => [2,3]\ncount_up_to(11) => [2,3,5,7]\ncount_up_to(0) => []\ncount_up_to(20) => [2,3,5,7,11,13,17,19]\ncount_up_to(1) => []\ncount_up_to(18) => [2,3,5,7,11,13,17]\"\"\"\n", "entry_point": "count_up_to", "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n", "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"}
{"task_id": "HumanEval/106", "prompt": "\ndef f(n):\n    \"\"\"Implementieren Sie die Funktion f, die n als Parameter akzeptiert und eine Liste der Größe n zurückgibt, sodass der Wert des Elements an Index i das Faktorielle von i ist, wenn i gerade ist, oder die Summe der Zahlen von 1 bis i sonst. i beginnt bei 1. Das Faktorielle von i ist das Produkt der Zahlen von 1 bis i (1 * 2 * ... * i). Beispiel: f(5) == [1, 2, 6, 24, 15]\"\"\"\n", "entry_point": "f", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"}
{"task_id": "HumanEval/80", "prompt": "\ndef is_happy(s):\n    \"\"\"Du erhältst einen String s.\nDeine Aufgabe ist es zu überprüfen, ob der String glücklich ist oder nicht.\nEin String ist glücklich, wenn seine Länge mindestens 3 beträgt und jede Gruppe von 3 aufeinanderfolgenden Buchstaben unterschiedlich ist.\nZum Beispiel:\nis_happy(a) => False\nis_happy(aa) => False\nis_happy(abcd) => True\nis_happy(aabb) => False\nis_happy(adb) => True\nis_happy(xyy) => False\"\"\"\n", "entry_point": "is_happy", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"}
{"task_id": "HumanEval/122", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"Gegeben sei ein nicht-leeres Array von ganzen Zahlen arr und eine ganze Zahl k. Gib die Summe der Elemente mit höchstens zwei Ziffern aus den ersten k Elementen von arr zurück.\n\nBeispiel:\n\n    Eingabe: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Ausgabe: 24 # Summe von 21 + 3\n\nEinschränkungen:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\"\"\"\n", "entry_point": "add_elements", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/33", "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"Diese Funktion nimmt eine Liste l und gibt eine Liste l' zurück, sodass\n    l' in den Indizes, die nicht durch drei teilbar sind, identisch mit l ist, während die Werte an den Indizes, die durch drei teilbar sind, gleich sind\n    den Werten der entsprechenden Indizes von l, aber sortiert.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\"\"\"\n", "entry_point": "sort_third", "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"}
{"task_id": "HumanEval/76", "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"Ihre Aufgabe besteht darin, eine Funktion zu schreiben, die true zurückgibt, wenn eine Zahl x eine einfache Potenz von n ist, und false in allen anderen Fällen.\nx ist eine einfache Potenz von n, wenn n**int=x.\nZum Beispiel:\nis_simple_power(1, 4) => true\nis_simple_power(2, 2) => true\nis_simple_power(8, 2) => true\nis_simple_power(3, 2) => false\nis_simple_power(3, 1) => false\nis_simple_power(5, 3) => false\"\"\"\n", "entry_point": "is_simple_power", "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/103", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Du erhältst zwei positive Ganzzahlen n und m und deine Aufgabe ist es, den Durchschnitt der Zahlen von n bis m (einschließlich n und m) zu berechnen. Runde die Antwort auf die nächste Ganzzahl und konvertiere das in binär. Wenn n größer als m ist, gib -1 zurück.\nBeispiel:\nrounded_avg(1, 5) => \"0b11\"\nrounded_avg(7, 5) => -1\nrounded_avg(10, 20) => \"0b1111\"\nrounded_avg(20, 33) => \"0b11010\"\"\"\n", "entry_point": "rounded_avg", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"}
{"task_id": "HumanEval/89", "prompt": "\ndef encrypt(s):\n    \"\"\"Erstellen Sie eine Funktion \"encrypt\", die einen String als Argument nimmt und einen mit dem rotierten Alphabet verschlüsselten String zurückgibt. Das Alphabet sollte so gedreht werden, dass die Buchstaben um zwei multipliziert mit zwei Stellen nach unten verschoben werden. Zum Beispiel: encrypt('hi') gibt 'lm' zurück encrypt('asdfghjkl') gibt 'ewhjklnop' zurück encrypt('gf') gibt 'kj' zurück encrypt('et') gibt 'ix' zurück\"\"\"\n", "entry_point": "encrypt", "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/137", "prompt": "\ndef compare_one(a, b):\n    \"\"\"Erstelle eine Funktion, die Ganzzahlen, Gleitkommazahlen oder Zeichenketten annimmt, die reale Zahlen repräsentieren, und gibt die größere Variable in ihrem gegebenen Variablentyp zurück. Gib None zurück, wenn die Werte gleich sind. Hinweis: Wenn eine reale Zahl als Zeichenkette dargestellt wird, kann der Dezimalpunkt . oder , sein.\n\ncompare_one(1, 2.5) ➞ 2.5\ncompare_one(1, \"2,3\") ➞ \"2,3\"\ncompare_one(\"5,1\", \"6\") ➞ \"6\"\ncompare_one(\"1\", 1) ➞ None\"\"\"\n", "entry_point": "compare_one", "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/43", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"pairs_sum_to_zero nimmt eine Liste von Ganzzahlen als Eingabe an.\nEs gibt True zurück, wenn es zwei verschiedene Elemente in der Liste gibt, die zu Null addieren, und False sonst.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\nFalse\n>>> pairs_sum_to_zero([1, 3, -2, 1])\nFalse\n>>> pairs_sum_to_zero([1, 2, 3, 7])\nFalse\n>>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\nTrue\n>>> pairs_sum_to_zero([1])\nFalse\"\"\"\n", "entry_point": "pairs_sum_to_zero", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"}
{"task_id": "HumanEval/95", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"Gegeben ein Wörterbuch, gib True zurück, wenn alle Schlüssel entweder in Kleinbuchstaben oder in Großbuchstaben als Strings sind, sonst gib False zurück. Die Funktion sollte False zurückgeben, wenn das gegebene Wörterbuch leer ist. Beispiele: check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) sollte True zurückgeben. check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) sollte False zurückgeben. check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) sollte False zurückgeben. check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) sollte False zurückgeben. check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) sollte True zurückgeben.\"\"\"\n", "entry_point": "check_dict_case", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"}
{"task_id": "HumanEval/41", "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"Stellen Sie sich eine Straße vor, die eine perfekt gerade, unendlich lange Linie ist.\nn Autos fahren von links nach rechts; gleichzeitig fährt eine andere Gruppe von n Autos von rechts nach links. Die beiden Gruppen von Autos sind am Anfang sehr weit voneinander entfernt. Alle Autos bewegen sich mit derselben Geschwindigkeit. Zwei Autos stoßen zusammen, wenn ein Auto, das von links nach rechts fährt, mit einem Auto zusammenstößt, das von rechts nach links fährt. Die Autos sind jedoch unendlich robust und stark; daher setzen sie ihre Bewegung fort, als ob sie keinen Zusammenstoß gehabt hätten.\n\nDiese Funktion gibt die Anzahl solcher Kollisionen aus.\"\"\"\n", "entry_point": "car_race_collision", "canonical_solution": "    return n**2\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"}
{"task_id": "HumanEval/105", "prompt": "\ndef by_length(arr):\n    \"\"\"Gegeben ein Array von ganzen Zahlen, sortieren Sie die Zahlen, die zwischen 1 und 9 (einschließlich) liegen, umgekehrt das resultierende Array und ersetzen Sie dann jede Ziffer durch ihren entsprechenden Namen aus \"Eins\", \"Zwei\", \"Drei\", \"Vier\", \"Fünf\", \"Sechs\", \"Sieben\", \"Acht\", \"Neun\".\n\nZum Beispiel:\n  arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n        -> sortieren arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n        -> umkehren arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n  Rückgabe [\"Acht\", \"Fünf\", \"Vier\", \"Drei\", \"Zwei\", \"Zwei\", \"Eins\", \"Eins\"]\n\n  Wenn das Array leer ist, geben Sie ein leeres Array zurück:\n  arr = []\n  Rückgabe []\n\n  Wenn das Array eine seltsame Zahl enthält, ignorieren Sie diese:\n  arr = [1, -1 , 55] \n        -> sortieren arr -> [-1, 1, 55]\n        -> umkehren arr -> [55, 1, -1]\n  Rückgabe ['Eins']\"\"\"\n", "entry_point": "by_length", "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"}
{"task_id": "HumanEval/40", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero nimmt eine Liste von Ganzzahlen als Eingabe entgegen. Es gibt True zurück, wenn es drei verschiedene Elemente in der Liste gibt, die zu Null addiert werden, andernfalls gibt es False zurück.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\"\"\"\n", "entry_point": "triples_sum_to_zero", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"}
{"task_id": "HumanEval/101", "prompt": "\ndef words_string(s):\n    \"\"\"Sie erhalten einen String von Wörtern, die durch Kommas oder Leerzeichen getrennt sind. Ihre Aufgabe besteht darin, den String in Wörter aufzuteilen und ein Array der Wörter zurückzugeben.\n\nZum Beispiel:\nwords_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nwords_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\"\"\"\n", "entry_point": "words_string", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"}
{"task_id": "HumanEval/150", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Ein einfaches Programm, das den Wert von x zurückgeben sollte, wenn n eine Primzahl ist, und anderenfalls den Wert von y zurückgeben sollte.\n\nBeispiele:\nfür x_or_y(7, 34, 12) == 34\nfür x_or_y(15, 8, 5) == 5\"\"\"\n", "entry_point": "x_or_y", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"}
{"task_id": "HumanEval/39", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib gibt die n-te Zahl zurück, die sowohl eine Fibonacci-Zahl als auch eine Primzahl ist. \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\"\"\"\n", "entry_point": "prime_fib", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"}
{"task_id": "HumanEval/46", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"Die Fib4-Zahlenreihe ist eine Reihe ähnlich der Fibonaccisequenz, die wie folgt definiert ist:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Bitte schreiben Sie eine Funktion, um das n-te Element der Fib4-Zahlenreihe effizient zu berechnen. Verwenden Sie keine Rekursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\"\"\"\n", "entry_point": "fib4", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"}
{"task_id": "HumanEval/112", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Aufgabe\n    Wir haben zwei Zeichenketten s und c. Sie müssen alle Zeichen in s löschen, die mit einem Zeichen in c übereinstimmen.\n    Überprüfen Sie dann, ob die resultierende Zeichenkette ein Palindrom ist.\n    Eine Zeichenkette heißt Palindrom, wenn sie rückwärts gelesen genauso ist wie vorwärts.\n    Sie sollten ein Tupel zurückgeben, das die resultierende Zeichenkette und True/False für die Überprüfung enthält.\n    Beispiel\n    Für s = \"abcde\" und c = \"ae\" sollte das Ergebnis ('bcd',False) sein.\n    Für s = \"abcdef\" und c = \"b\" sollte das Ergebnis ('acdef',False) sein.\n    Für s = \"abcdedcba\" und c = \"ab\" sollte das Ergebnis ('cdedc',True) sein.\"\"\"\n", "entry_point": "reverse_delete", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"}
{"task_id": "HumanEval/81", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"Es ist die letzte Woche des Semesters und der Lehrer muss den Schülern die Noten geben. Der Lehrer hat einen eigenen Algorithmus zur Bewertung entwickelt. Das einzige Problem ist, dass er den Code, den er für die Bewertung verwendet hat, verloren hat. Er hat Ihnen eine Liste der Grade Point Averages (GPAs) für einige Schüler gegeben und Sie müssen eine Funktion schreiben, die eine Liste der Buchstabennoten gemäß der folgenden Tabelle ausgibt:\n\n             GPA       |    Buchstaben Note\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Beispiel:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n", "entry_point": "numerical_letter_grade", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/116", "prompt": "\ndef sort_array(arr):\n    \"\"\"In diesem Kata müssen Sie ein Array von nicht-negativen Ganzzahlen entsprechend der Anzahl der Einsen in ihrer binären Darstellung in aufsteigender Reihenfolge sortieren. Bei gleicher Anzahl von Einsen wird nach dem Dezimalwert sortiert.\n\nEs muss folgendermaßen implementiert werden:\n>>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n>>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n>>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\"\"\"\n", "entry_point": "sort_array", "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/147", "prompt": "\ndef get_max_triples(n):\n    \"\"\"Sie erhalten eine positive Ganzzahl n. Sie müssen ein Ganzzahlen-Array a der Länge n erstellen.\n     Für jedes i (1 ≤ i ≤ n) gilt für den Wert von a[i]: a[i] = i * i - i + 1.\n     Geben Sie die Anzahl der Tripel (a[i], a[j], a[k]) von a zurück, bei denen i < j < k gilt und a[i] + a[j] + a[k] ein Vielfaches von 3 ist.\n\n    Beispiel:\n      Eingabe: n = 5\n      Ausgabe: 1\n      Erklärung:\n      a = [1, 3, 7, 13, 21]\n      Das einzige gültige Tripel ist (1, 7, 13).\"\"\"\n", "entry_point": "get_max_triples", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"}
{"task_id": "HumanEval/128", "prompt": "\ndef prod_signs(arr):\n    \"\"\"Sie erhalten ein Array arr von Ganzzahlen und müssen die Summe der Beträge der Ganzzahlen zurückgeben, die mit dem Produkt aller Zeichen jedes Elements im Array multipliziert werden, dargestellt durch 1, -1 oder 0. Hinweis: Geben Sie für ein leeres Array None zurück.\n\nBeispiel:\n>>> prod_signs([1, 2, 2, -4]) == -9\n>>> prod_signs([0, 1]) == 0\n>>> prod_signs([]) == None\"\"\"\n", "entry_point": "prod_signs", "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/88", "prompt": "\ndef sort_array(array):\n    \"\"\"Gegeben sei ein Array von nicht-negativen ganzen Zahlen. Gebe eine Kopie des gegebenen Arrays zurück, nachdem es sortiert wurde. Wenn die Summe (Wert des ersten Index + Wert des letzten Index) ungerade ist, wird das Array aufsteigend sortiert. Andernfalls wird es absteigend sortiert.\n\nHinweis:\n* Ändere das gegebene Array nicht.\n\nBeispiele:\n* sort_array([]) => []\n* sort_array([5]) => [5]\n* sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n* sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\"\"\"\n", "entry_point": "sort_array", "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"}
{"task_id": "HumanEval/117", "prompt": "\ndef select_words(s, n):\n    \"\"\"Gegeben eine Zeichenkette s und eine natürliche Zahl n, sind Sie beauftragt, eine Funktion zu implementieren, die eine Liste aller Wörter aus der Zeichenkette s zurückgibt, die genau n Konsonanten enthalten, in der Reihenfolge, in der diese Wörter in der Zeichenkette s erscheinen.\nWenn die Zeichenkette s leer ist, sollte die Funktion eine leere Liste zurückgeben.\nHinweis: Sie können davon ausgehen, dass die Eingabezeichenkette nur Buchstaben und Leerzeichen enthält.\nBeispiele:\nselect_words(\"Mary hatte ein kleines Lamm\", 4) ==> [\"kleines\"]\nselect_words(\"Mary hatte ein kleines Lamm\", 3) ==> [\"Mary\", \"Lamm\"]\nselect_words(\"einfacher Leerzeichen\", 2) ==> []\nselect_words(\"Hallo Welt\", 4) ==> [\"Welt\"]\nselect_words(\"Onkel Sam\", 3) ==> [\"Onkel\"]\"\"\"\n", "entry_point": "select_words", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"}
{"task_id": "HumanEval/142", "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"Die Funktion erhält eine Liste von ganzen Zahlen. Für alle Einträge in der Liste quadriert die Funktion die ganze Zahl, wenn der Index ein Vielfaches von 3 ist, und kubiert die ganze Zahl, wenn der Index ein Vielfaches von 4 ist und kein Vielfaches von 3 ist. Die Funktion ändert die Einträge in der Liste nicht, deren Index kein Vielfaches von 3 oder 4 ist. Die Funktion gibt dann die Summe aller Einträge zurück.\n\nBeispiele:\nFür lst = [1,2,3] ist die Ausgabe 6\nFür lst = [] ist die Ausgabe 0\nFür lst = [-1,-5,2,-1,-5] ist die Ausgabe -126\"\"\"\n", "entry_point": "sum_squares", "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"}
{"task_id": "HumanEval/107", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"Gegeben eine positive ganze Zahl n, gib ein Tupel zurück, das die Anzahl der geraden und ungeraden ganzen Palindrome enthält, die im Bereich (1, n) liegen, einschließlich.\n\nBeispiel 1:\n\n    Eingabe: 3\n    Ausgabe: (1, 2)\n    Erklärung:\n    Ganze Palindrome sind 1, 2, 3. Eines davon ist gerade und zwei davon sind ungerade.\n\nBeispiel 2:\n\n    Eingabe: 12\n    Ausgabe: (4, 6)\n    Erklärung:\n    Ganze Palindrome sind 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Vier davon sind gerade und sechs davon sind ungerade.\n\nHinweis:\n    1. 1 <= n <= 10^3\n    2. Das zurückgegebene Tupel hat die Anzahl der geraden und ungeraden ganzen Palindrome.\"\"\"\n", "entry_point": "even_odd_palindrome", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/133", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Sie erhalten eine Liste von Zahlen. Sie müssen die Summe der quadrierten Zahlen in der gegebenen Liste zurückgeben und jedes Element in der Liste zuerst auf die obere Ganzzahl (Decke) runden.\nBeispiele:\nFür lst = [1,2,3] sollte die Ausgabe 14 sein.\nFür lst = [1,4,9] sollte die Ausgabe 98 sein.\nFür lst = [1,3,5,7] sollte die Ausgabe 84 sein.\nFür lst = [1.4,4.2,0] sollte die Ausgabe 29 sein.\nFür lst = [-2.4,1,1] sollte die Ausgabe 6 sein.\"\"\"\n", "entry_point": "sum_squares", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/162", "prompt": "\ndef string_to_md5(text):\n    \"\"\"Gegeben einen String 'text', gib seine md5-hash-Äquivalent-Zeichenkette zurück.\nWenn 'text' eine leere Zeichenkette ist, gib None zurück.\n\n>>> string_to_md5('Hallo Welt') == '3e25960a79dbc69b674cd4ec67a72c62'\"\"\"\n", "entry_point": "string_to_md5", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/30", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Original Text: \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\nTranslation: \"\"\"Geben Sie nur positive Zahlen in der Liste zurück.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n", "entry_point": "get_positive", "canonical_solution": "    return [e for e in l if e > 0]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"}
{"task_id": "HumanEval/152", "prompt": "\ndef compare(game,guess):\n    \"\"\"Ich denke, wir erinnern uns alle an das Gefühl, wenn das Ergebnis eines lang erwarteten Ereignisses endlich bekannt ist. Die Gefühle und Gedanken, die man in diesem Moment hat, sind definitiv wert, sie festzuhalten und zu vergleichen. Ihre Aufgabe besteht darin, festzustellen, ob eine Person die Ergebnisse einer Reihe von Spielen richtig geraten hat. Ihnen werden zwei Arrays mit Punktzahlen und Vermutungen gleicher Länge gegeben, wobei jeder Index ein Spiel darstellt. Geben Sie ein Array der gleichen Länge zurück, das angibt, wie weit jede Vermutung daneben lag. Wenn sie richtig geraten haben, ist der Wert 0, andernfalls ist der Wert der absolute Unterschied zwischen der Vermutung und der Punktzahl.\n\nBeispiel:\n\ncompare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\ncompare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\"\"\"\n", "entry_point": "compare", "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/63", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"Die FibFib-Zahlenfolge ist eine Folge, die der Fibonacci-Folge ähnelt und wie folgt definiert ist:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\nBitte schreiben Sie eine Funktion, um das n-te Element der FibFib-Zahlenfolge effizient zu berechnen.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\"\"\"\n", "entry_point": "fibfib", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"}
{"task_id": "HumanEval/144", "prompt": "\ndef simplify(x, n):\n    \"\"\"Ihre Aufgabe besteht darin, eine Funktion zu implementieren, die den Ausdruck x * n vereinfacht. Die Funktion gibt True zurück, wenn x * n zu einer ganzen Zahl ausgewertet wird, andernfalls False. Sowohl x als auch n sind eine Zeichenkette, die eine Bruchzahl repräsentiert, und haben das folgende Format: <Zähler>/<Nenner>, wobei sowohl Zähler als auch Nenner positive ganze Zahlen sind.\n\nSie können davon ausgehen, dass x und n gültige Bruchzahlen sind und keinen Nenner von Null haben.\n\nvereinfachen(\"1/5\", \"5/1\") = True\nvereinfachen(\"1/6\", \"2/1\") = False\nvereinfachen(\"7/10\", \"10/2\") = False\"\"\"\n", "entry_point": "simplify", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n"}
{"task_id": "HumanEval/120", "prompt": "\ndef maximum(arr, k):\n    \"\"\"Gegeben ist ein Array arr von Ganzzahlen und eine positive Ganzzahl k. Gib eine sortierte Liste der Länge k mit den größten k Zahlen in arr zurück.\n\nBeispiel 1:\n\n    Eingabe: arr = [-3, -4, 5], k = 3\n    Ausgabe: [-4, -3, 5]\n\nBeispiel 2:\n\n    Eingabe: arr = [4, -4, 4], k = 2\n    Ausgabe: [4, 4]\n\nBeispiel 3:\n\n    Eingabe: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Ausgabe: [2]\n\nHinweis:\n    1. Die Länge des Arrays wird im Bereich von [1, 1000] liegen.\n    2. Die Elemente im Array werden im Bereich von [-1000, 1000] liegen.\n    3. 0 <= k <= len(arr)\"\"\"\n", "entry_point": "maximum", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"}
{"task_id": "HumanEval/86", "prompt": "\ndef anti_shuffle(s):\n    \"\"\"Schreiben Sie eine Funktion, die einen String entgegennimmt und eine geordnete Version davon zurückgibt. Geordnete Version des Strings bedeutet, dass alle Wörter (getrennt durch Leerzeichen) durch ein neues Wort ersetzt werden, in dem alle Zeichen basierend auf dem ASCII-Wert aufsteigend angeordnet sind. Hinweis: Sie sollten die Reihenfolge der Wörter und Leerzeichen im Satz beibehalten.\n\nZum Beispiel:\nanti_shuffle('Hi') gibt 'Hi' zurück\nanti_shuffle('hello') gibt 'ehllo' zurück\nanti_shuffle('Hello World!!!') gibt 'Hello !!!Wdlor' zurück\"\"\"\n", "entry_point": "anti_shuffle", "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/145", "prompt": "\ndef order_by_points(nums):\n    \"\"\"Schreiben Sie eine Funktion, die die gegebene Liste von Ganzzahlen in aufsteigender Reihenfolge nach der Summe ihrer Ziffern sortiert. Hinweis: Wenn es mehrere Elemente mit ähnlicher Summe ihrer Ziffern gibt, ordnen Sie sie basierend auf ihrem Index in der Originalliste. Zum Beispiel: >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11] >>> order_by_points([]) == []\"\"\"\n", "entry_point": "order_by_points", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/130", "prompt": "\ndef tri(n):\n    \"\"\"Jeder kennt die Fibonacci-Folge, sie wurde in den letzten Jahrhunderten von Mathematikern tiefgehend untersucht. Was die meisten Menschen jedoch nicht wissen, ist die Tribonacci-Folge. Die Tribonacci-Folge wird durch die Rekursion definiert:\n\ntri(1) = 3\ntri(n) = 1 + n / 2, wenn n gerade ist.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), wenn n ungerade ist.\n\nBeispiel:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n       = 2 + 3 + 3 = 8\n\nDu erhältst eine nicht-negative Ganzzahl n. Du musst eine Liste der ersten n + 1 Zahlen der Tribonacci-Folge zurückgeben.\n\nBeispiele:\ntri(3) = [1, 3, 2, 8]\"\"\"\n", "entry_point": "tri", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"}
{"task_id": "HumanEval/87", "prompt": "\ndef get_row(lst, x):\n    \"\"\"Du erhältst eine zweidimensionale Datenstruktur als verschachtelte Listen, die ähnlich wie eine Matrix ist. Jedoch können im Gegensatz zur Matrix in jeder Zeile eine unterschiedliche Anzahl von Spalten vorkommen. Gegeben sei `lst` und eine ganze Zahl `x`. Finde in der Liste `x` und gib eine Liste von Tupeln zurück, die in Form von Koordinaten (Zeile, Spalte) angegeben sind, beginnend mit 0. Sortiere die Koordinaten zunächst nach aufsteigenden Zeilen und dann nach absteigenden Spalten in der gleichen Zeile.\n\nBeispiele:\n`get_row([\n  [1,2,3,4,5,6],\n  [1,2,3,4,1,6],\n  [1,2,3,4,5,1]\n], 1)` sollte `[(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]` zurückgeben.\n`get_row([], 1)` sollte `[]` zurückgeben.\n`get_row([[], [1], [1, 2, 3]], 3)` sollte `[(2, 2)]` zurückgeben.\"\"\"\n", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/129", "prompt": "\ndef minPath(grid, k):\n    \"\"\"Gegeben ist ein Gitter mit N Zeilen und N Spalten (N >= 2) und einer positiven Ganzzahl k. Jede Zelle des Gitters enthält einen Wert. Jede Ganzzahl im Bereich [1, N * N] erscheint genau einmal in den Zellen des Gitters.\n\nSie müssen den Pfad der Länge k im Gitter finden. Sie können von jeder Zelle aus starten und in jedem Schritt zu einer benachbarten Zelle gehen, das heißt, Sie können zu Zellen gehen, die eine Kante mit Ihrer aktuellen Zelle teilen.\nBitte beachten Sie, dass ein Pfad der Länge k bedeutet, dass genau k Zellen besucht werden (nicht unbedingt verschieden).\nEs ist NICHT möglich, außerhalb des Gitters zu gehen.\nEin Pfad A (der Länge k) gilt als kleiner als ein Pfad B (der Länge k), wenn nachdem die geordneten Listen der Werte der Zellen, die A und B durchlaufen (nennen wir sie lst_A und lst_B), erstellt wurden, lst_A lexikographisch kleiner ist als lst_B, mit anderen Worten, es gibt einen ganzzahligen Index i (1 <= i <= k), sodass lst_A[i] < lst_B[i] und für jedes j (1 <= j < i) haben wir lst_A[j] = lst_B[j].\nEs ist garantiert, dass die Antwort eindeutig ist.\nGeben Sie eine geordnete Liste der Werte der Zellen zurück, die der minimale Pfad durchläuft.\n\nBeispiele:\n\n    Eingabe: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n    Ausgabe: [1, 2, 1]\n\n    Eingabe: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n    Ausgabe: [1]\"\"\"\n", "entry_point": "minPath", "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"}
{"task_id": "HumanEval/163", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"Gegeben sind zwei positive ganze Zahlen a und b, gibt die geraden Ziffern zwischen a und b in aufsteigender Reihenfolge zurück.\n\nZum Beispiel:\ngenerate_integers(2, 8) => [2, 4, 6, 8]\ngenerate_integers(8, 2) => [2, 4, 6, 8]\ngenerate_integers(10, 14) => []\"\"\"\n", "entry_point": "generate_integers", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/115", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"Dir wird ein rechteckiges Raster von Brunnen gegeben. Jede Zeile stellt einen einzelnen Brunnen dar und jede 1 in einer Zeile stellt eine einzelne Einheit Wasser dar. Jeder Brunnen hat einen entsprechenden Eimer, mit dem Wasser daraus entnommen werden kann, und alle Eimer haben die gleiche Kapazität. Deine Aufgabe ist es, die Eimer zu verwenden, um die Brunnen zu leeren. Gib die Anzahl der Male aus, die du die Eimer senken musst.\n\nBeispiel 1:\n    Eingabe:\n        grid: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        bucket_capacity: 1\n    Ausgabe: 6\n\nBeispiel 2:\n    Eingabe:\n        grid: [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        bucket_capacity: 2\n    Ausgabe: 5\n\nBeispiel 3:\n    Eingabe:\n        grid: [[0,0,0], [0,0,0]]\n        bucket_capacity: 5\n    Ausgabe: 0\n\nEinschränkungen:\n    * Alle Brunnen haben die gleiche Länge\n    * 1 <= grid.Länge <= 10^2\n    * 1 <= grid[:,1].Länge <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= capacity <= 10\"\"\"\n", "entry_point": "max_fill", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"}
{"task_id": "HumanEval/141", "prompt": "\ndef file_name_check(file_name):\n    \"\"\"Erstellen Sie eine Funktion, die einen String als Dateinamen darstellt und 'Ja' zurückgibt, wenn der Dateiname gültig ist, andernfalls 'Nein'. Ein Dateiname gilt nur dann als gültig, wenn alle folgenden Bedingungen erfüllt sind:\n- Es sollten nicht mehr als drei Ziffern ('0'-'9') im Dateinamen vorhanden sein.\n- Der Dateiname enthält genau einen Punkt '.'.\n- Der Teilstring vor dem Punkt darf nicht leer sein und muss mit einem Buchstaben aus dem lateinischen Alphabet ('a'-'z' und 'A'-'Z') beginnen.\n- Der Teilstring nach dem Punkt muss einer dieser Werte sein: ['txt', 'exe', 'dll']\nBeispiele:\nfile_name_check(\"beispiel.txt\") # => 'Ja'\nfile_name_check(\"1beispiel.dll\") # => 'Nein' (der Name sollte mit einem Buchstaben aus dem lateinischen Alphabet beginnen)\"\"\"\n", "entry_point": "file_name_check", "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"}
{"task_id": "HumanEval/123", "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"Gegeben eine positive ganze Zahl n, gib eine sortierte Liste zurück, die die ungeraden Zahlen in der Collatz-Folge enthält.\n\nDie Collatz-Vermutung ist eine Vermutung in der Mathematik, die sich auf eine Folge bezieht, die wie folgt definiert ist: Starte mit einer beliebigen positiven ganzen Zahl n. Dann wird jeder Term aus dem vorherigen Term wie folgt erhalten: Wenn der vorherige Term gerade ist, ist der nächste Term die Hälfte des vorherigen Terms. Wenn der vorherige Term ungerade ist, ist der nächste Term das dreifache des vorherigen Terms plus 1. Die Vermutung besagt, dass unabhängig von der Wert von n, die Folge immer 1 erreicht.\n\nHinweis:\n    1. Collatz(1) ist [1].\n    2. Die zurückgegebene Liste ist in aufsteigender Reihenfolge sortiert.\n\nZum Beispiel:\nget_odd_collatz(5) gibt [1, 5] zurück # Die Collatz-Folge für 5 ist [5, 16, 8, 4, 2, 1], daher sind die ungeraden Zahlen nur 1 und 5.\"\"\"\n", "entry_point": "get_odd_collatz", "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/146", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Schreiben Sie eine Funktion, die als Eingabe ein Array von Zahlen annimmt und die Anzahl der Elemente im Array zurückgibt, die größer als 10 sind und bei denen sowohl die erste als auch die letzte Ziffer der Zahl ungerade sind (1, 3, 5, 7, 9).\nZum Beispiel:\nspecialFilter([15, -73, 14, -15]) => 1\nspecialFilter([33, -2, -3, 45, 21, 109]) => 2\"\"\"\n", "entry_point": "specialFilter", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"}
{"task_id": "HumanEval/110", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"In diesem Problem implementieren Sie eine Funktion, die zwei Listen von Zahlen entgegennimmt und bestimmt, ob es möglich ist, einen Austausch von Elementen zwischen ihnen durchzuführen, um lst1 zu einer Liste nur mit geraden Zahlen zu machen. Es gibt keine Begrenzung für die Anzahl ausgetauschter Elemente zwischen lst1 und lst2. Wenn es möglich ist, Elemente zwischen lst1 und lst2 auszutauschen, um alle Elemente von lst1 gerade zu machen, geben Sie \"JA\" zurück. Andernfalls geben Sie \"NEIN\" zurück. Zum Beispiel: Austausch([1, 2, 3, 4], [1, 2, 3, 4]) => \"JA\" Austausch([1, 2, 3, 4], [1, 5, 3, 4]) => \"NEIN\" Es wird davon ausgegangen, dass die Eingabelisten nicht leer sein werden.\"\"\"\n", "entry_point": "exchange", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"}
{"task_id": "HumanEval/78", "prompt": "\ndef hex_key(num):\n    \"\"\"Sie wurden beauftragt, eine Funktion zu schreiben, die eine hexadezimale Zahl als Zeichenkette erhält und die Anzahl der hexadezimalen Ziffern zählt, die Primzahlen sind (eine Primzahl oder eine Primzahl ist eine natürliche Zahl größer als 1, die kein Produkt zweier kleinerer natürlicher Zahlen ist).\nHexadezimale Ziffern sind 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrimzahlen sind 2, 3, 5, 7, 11, 13, 17,...\nSie müssen also die Anzahl der folgenden Ziffern bestimmen: 2, 3, 5, 7, B (= dezimal 11), D (= dezimal 13).\nHinweis: Sie können davon ausgehen, dass die Eingabe immer korrekt oder eine leere Zeichenkette ist, und die Symbole A, B, C, D, E, F sind immer in Großbuchstaben.\nBeispiele:\nFür num = \"AB\" sollte die Ausgabe 1 sein.\nFür num = \"1077E\" sollte die Ausgabe 2 sein.\nFür num = \"ABED1A33\" sollte die Ausgabe 4 sein.\nFür num = \"123456789ABCDEF0\" sollte die Ausgabe 6 sein.\nFür num = \"2020\" sollte die Ausgabe 2 sein.\"\"\"\n", "entry_point": "hex_key", "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"}
{"task_id": "HumanEval/154", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Dir werden 2 Wörter gegeben. Du musst True zurückgeben, wenn das zweite Wort oder eine seiner Rotationen eine Teilzeichenkette im ersten Wort ist.\ncycpattern_check(\"abcd\",\"abd\") => False\ncycpattern_check(\"hello\",\"ell\") => True\ncycpattern_check(\"whassup\",\"psus\") => False\ncycpattern_check(\"abab\",\"baa\") => True\ncycpattern_check(\"efef\",\"eeff\") => False\ncycpattern_check(\"himenss\",\"simen\") => True\"\"\"\n", "entry_point": "cycpattern_check", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"}
{"task_id": "HumanEval/156", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"Geben Sie eine positive ganze Zahl an und erhalten Sie ihre römische Zahl als Zeichenkette, und geben Sie sie in Kleinbuchstaben zurück.\nBeschränkungen: 1 <= num <= 1000\n\nBeispiele:\n>>> int_to_mini_roman(19) == 'xix'\n>>> int_to_mini_roman(152) == 'clii'\n>>> int_to_mini_roman(426) == 'cdxxvi'\"\"\"\n", "entry_point": "int_to_mini_roman", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/155", "prompt": "\ndef even_odd_count(num):\n    \"\"\"Gegeben eine Ganzzahl. Gib ein Tupel zurück, das die Anzahl der geraden und ungeraden Ziffern enthält.\n\n     Beispiel:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\"\"\"\n", "entry_point": "even_odd_count", "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/68", "prompt": "\ndef pluck(arr):\n    \"\"\"Geben Sie ein Array, das einen Ast eines Baums darstellt und nicht-negative ganze Zahlenknoten hat.\nIhre Aufgabe ist es, einen der Knoten zu entfernen und ihn zurückzugeben.\nDer entfernte Knoten sollte der Knoten mit dem kleinsten geraden Wert sein.\nWenn mehrere Knoten mit dem selben kleinsten geraden Wert gefunden werden, geben Sie den Knoten mit dem kleinsten Index zurück.\n\nDer entfernte Knoten sollte als Liste zurückgegeben werden, [kleinster Wert, sein Index],\nWenn keine geraden Werte vorhanden sind oder das gegebene Array leer ist, geben Sie [] zurück.\n\nBeispiel 1:\n    Eingabe: [4,2,3]\n    Ausgabe: [2, 1]\n    Erklärung: 2 hat den kleinsten geraden Wert und 2 hat den kleinsten Index.\n\nBeispiel 2:\n    Eingabe: [1,2,3]\n    Ausgabe: [2, 1]\n    Erklärung: 2 hat den kleinsten geraden Wert und 2 hat den kleinsten Index.\n\nBeispiel 3:\n    Eingabe: []\n    Ausgabe: []\n\nBeispiel 4:\n    Eingabe: [5, 0, 3, 0, 4, 2]\n    Ausgabe: [0, 1]\n    Erklärung: 0 ist der kleinste Wert, aber es gibt zwei Nullen,\n                 daher wählen wir die erste Null, die den kleinsten Index hat.\n\nEinschränkungen:\n    * 1 <= knoten.länge <= 10000\n    * 0 <= knoten.wert\"\"\"\n", "entry_point": "pluck", "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"}
{"task_id": "HumanEval/67", "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"In dieser Aufgabe erhalten Sie eine Zeichenkette, die eine Anzahl von Äpfeln und Orangen darstellt, die in einem Korb mit Obst verteilt sind. Dieser Korb enthält Äpfel, Orangen und Mangofrüchte. Gegeben die Zeichenkette, die die Gesamtzahl der Orangen und Äpfel darstellt, und eine Ganzzahl, die die Gesamtzahl der Früchte im Korb darstellt, geben Sie die Anzahl der Mangofrüchte im Korb zurück.\nBeispiel:\nfruit_distribution(\"5 Äpfel und 6 Orangen\", 19) -> 19 - 5 - 6 = 8\nfruit_distribution(\"0 Äpfel und 1 Orangen\",3) -> 3 - 0 - 1 = 2\nfruit_distribution(\"2 Äpfel und 3 Orangen\", 100) -> 100 - 2 - 3 = 95\nfruit_distribution(\"100 Äpfel und 1 Orangen\",120) -> 120 - 100 - 1 = 19\"\"\"\n", "entry_point": "fruit_distribution", "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"}
{"task_id": "HumanEval/161", "prompt": "\ndef solve(s):\n    \"\"\"Du hast einen String s. Wenn s[i] ein Buchstabe ist, kehre seinen Fall von Kleinbuchstabe zu Großbuchstabe oder umgekehrt um, ansonsten behalte es so wie es ist. Wenn der String keine Buchstaben enthält, kehre den String um. Die Funktion sollte den resultierenden String zurückgeben. Beispiele: solve(\"1234\") = \"4321\" solve(\"ab\") = \"AB\" solve(\"#a@C\") = \"#A@c\"\"\"\n", "entry_point": "solve", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"}
{"task_id": "HumanEval/160", "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"Gegeben sind zwei Listen \"operator\" und \"operand\". Die erste Liste enthält grundlegende algebraische Operationen, und die zweite Liste ist eine Liste von Ganzzahlen. Verwenden Sie die beiden gegebenen Listen, um den algebraischen Ausdruck aufzubauen und die Auswertung dieses Ausdrucks zurückzugeben.\n\nDie grundlegenden algebraischen Operationen sind:\nAddition (+)\nSubtraktion (-)\nMultiplikation (*)\nGanzzahldivision (//)\nPotenz ( ** )\n\nBeispiel:\noperator['+', '*', '-']\narray = [2, 3, 4, 5]\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nHinweis:\nDie Länge der Liste \"operator\" ist gleich der Länge der Liste \"operand\" minus eins.\n\"Operand\" ist eine Liste nicht-negativer Ganzzahlen.\nDie Liste \"operator\" enthält mindestens einen Operator, und die Liste \"operand\" enthält mindestens zwei Operanden.\"\"\"\n", "entry_point": "do_algebra", "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/109", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Wir haben ein Array \"arr\" von N Ganzzahlen arr[1], arr[2], ..., arr[N]. Die Zahlen im Array werden zufällig angeordnet sein. Ihre Aufgabe besteht darin festzustellen, ob es möglich ist, ein sortiertes Array in nicht aufsteigender Reihenfolge zu erhalten, indem Sie die folgende Operation auf das gegebene Array anwenden:\n\nEs ist Ihnen gestattet, die Rechtsverschiebung beliebig oft durchzuführen.\n\nEine Rechtsverschiebung bedeutet, dass alle Elemente des Arrays um eine Position in Richtung rechts verschoben werden. Das letzte Element des Arrays wird an die Anfangsposition im Array verschoben, d.h. zum Index 0.\n\nWenn es möglich ist, das sortierte Array durch Ausführung der oben genannten Operation zu erhalten, geben Sie True zurück, andernfalls geben Sie False zurück.\nWenn das gegebene Array leer ist, geben Sie True zurück.\n\nHinweis: Die gegebene Liste enthält garantiert eindeutige Elemente.\n\nBeispiel:\n\nmove_one_ball([3, 4, 5, 1, 2])==True\nErklärung: Durch Ausführen von 2 Rechtsverschiebungsoperationen kann die nicht absteigende Reihenfolge für das gegebene Array erreicht werden.\nmove_one_ball([3, 5, 4, 1, 2])==False\nErklärung: Es ist nicht möglich, eine nicht absteigende Reihenfolge für das gegebene Array durch Ausführen beliebiger Anzahl von Rechtsverschiebungen zu erhalten.\"\"\"\n", "entry_point": "move_one_ball", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"}
{"task_id": "HumanEval/153", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Sie erhalten den Namen einer Klasse (eine Zeichenkette) und eine Liste von Erweiterungen.\nDie Erweiterungen sollen verwendet werden, um zusätzliche Klassen zur Klasse zu laden. Die Stärke der Erweiterung wird wie folgt definiert: Sei CAP die Anzahl der Großbuchstaben im Namen der Erweiterung und sei SM die Anzahl der Kleinbuchstaben im Namen der Erweiterung. Die Stärke wird durch den Bruch CAP - SM gegeben. Sie sollten die stärkste Erweiterung finden und eine Zeichenkette in folgendem Format zurückgeben: ClassName.StärksterErweiterungsname.\nWenn es zwei oder mehr Erweiterungen mit derselben Stärke gibt, sollten Sie diejenige wählen, die zuerst in der Liste vorkommt.\nZum Beispiel, wenn Ihnen \"Slices\" als Klasse und eine Liste der Erweiterungen ['SErviNGSliCes', 'Cheese', 'StuFfed'] gegeben wird, sollten Sie 'Slices.SErviNGSliCes' zurückgeben, da 'SErviNGSliCes' die stärkste Erweiterung ist (ihre Stärke beträgt -1).\nBeispiel:\nfür Strongest_Extension('meine_klasse', ['AA', 'Be', 'CC']) == 'meine_klasse.AA'\"\"\"\n", "entry_point": "Strongest_Extension", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"}
{"task_id": "HumanEval/143", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"Du hast einen String, der einen Satz repräsentiert.\nDer Satz enthält einige Wörter, die durch Leerzeichen getrennt sind.\nDu musst einen String zurückgeben, der die Wörter aus dem Originalsatz enthält,\nderen Länge Primzahlen sind.\nDie Reihenfolge der Wörter im neuen String sollte die gleiche sein wie im Original.\n\nBeispiel 1:\n    Eingabe: sentence = \"This is a test\"\n    Ausgabe: \"is\"\n\nBeispiel 2:\n    Eingabe: sentence = \"lets go for swimming\"\n    Ausgabe: \"go for\"\n\nEinschränkungen:\n    * 1 <= len(sentence) <= 100\n    * sentence enthält nur Buchstaben\"\"\"\n", "entry_point": "words_in_sentence", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"}
{"task_id": "HumanEval/94", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Du hast eine Liste von ganzen Zahlen. \nDu musst den größten Primwert finden und die Summe seiner Ziffern zurückgeben.\n\nBeispiele:\nFür lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] sollte die Ausgabe 10 sein. \nFür lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] sollte die Ausgabe 25 sein. \nFür lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] sollte die Ausgabe 13 sein. \nFür lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] sollte die Ausgabe 11 sein. \nFür lst = [0,81,12,3,1,21] sollte die Ausgabe 3 sein. \nFür lst = [0,8,1,2,1,7] sollte die Ausgabe 7 sein.\"\"\"\n", "entry_point": "skjkasdkd", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"}
{"task_id": "HumanEval/158", "prompt": "\ndef find_max(words):\n    \"\"\"Schreiben Sie eine Funktion, die eine Liste von Zeichenketten akzeptiert.\nDie Liste enthält verschiedene Wörter. Gib das Wort mit der höchsten Anzahl von eindeutigen Zeichen zurück. Wenn mehrere Zeichenketten die höchste Anzahl von eindeutigen Zeichen haben, gib dasjenige zurück, das in der lexikographischen Reihenfolge zuerst kommt.\n\nfind_max([\"name\", \"of\", \"string\"]) == \"string\"\nfind_max([\"name\", \"enam\", \"game\"]) == \"enam\"\nfind_max([\"aaaaaaa\", \"bb\", \"cc\"]) == \"\"aaaaaaa\"\"\"\n", "entry_point": "find_max", "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"}
{"task_id": "HumanEval/124", "prompt": "\ndef valid_date(date):\n    \"\"\"Du musst eine Funktion schreiben, die einen gegebenen Datumssatz überprüft und True zurückgibt, wenn das Datum gültig ist, andernfalls False.\nDas Datum ist gültig, wenn alle folgenden Regeln erfüllt sind:\n1. Der Datumssatz ist nicht leer.\n2. Die Anzahl der Tage ist nicht kleiner als 1 oder größer als 31 Tage für die Monate 1, 3, 5, 7, 8, 10, 12. Und die Anzahl der Tage ist nicht kleiner als 1 oder größer als 30 Tage für die Monate 4, 6, 9, 11. Und die Anzahl der Tage ist nicht kleiner als 1 oder größer als 29 für den Monat 2.\n3. Die Monate sollten nicht kleiner als 1 oder größer als 12 sein.\n4. Das Datum sollte im Format: mm-dd-yyyy vorliegen.\n\nzum Beispiel:\nvalid_date('03-11-2000') => True\n\nvalid_date('15-01-2012') => False\n\nvalid_date('04-0-2040') => False\n\nvalid_date('06-04-2020') => True\n\nvalid_date('06/04/2020') => False\"\"\"\n", "entry_point": "valid_date", "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"}
{"task_id": "HumanEval/127", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Sie erhalten zwei Intervalle, wobei jedes Intervall ein Paar von ganzen Zahlen ist. Zum Beispiel ist das Intervall = (start, end) = (1, 2). Die gegebenen Intervalle sind geschlossen, was bedeutet, dass das Intervall (start, end) sowohl den Anfang als auch das Ende einschließt. Bei jedem gegebenen Intervall wird angenommen, dass der Startwert kleiner oder gleich dem Endwert ist. Ihre Aufgabe besteht darin, festzustellen, ob die Länge der Schnittmenge dieser beiden Intervalle eine Primzahl ist. Beispiel: Die Schnittmenge der Intervalle (1, 3) und (2, 4) ist (2, 3), was eine Länge von 1 ergibt, was keine Primzahl ist. Wenn die Länge der Schnittmenge eine Primzahl ist, geben Sie \"YES\" zurück, sonst geben Sie \"NO\" zurück. Wenn sich die beiden Intervalle nicht überschneiden, geben Sie \"NO\" zurück.\n\n[input/output] samples:\nintersection((1, 2), (2, 3)) ==> \"NO\"\nintersection((-1, 1), (0, 4)) ==> \"NO\"\nintersection((-3, -1), (-5, 5)) ==> \"YES\"\"\"\n", "entry_point": "intersection", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"}
{"task_id": "HumanEval/159", "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"Du bist ein hungriges Kaninchen und hast bereits eine bestimmte Anzahl von Karotten gegessen, aber jetzt musst du noch mehr Karotten essen, um die Mahlzeiten des Tages zu vervollständigen. Du sollst ein Array zurückgeben mit [insgesamt gegessenen Karotten nach den Mahlzeiten, Anzahl der übriggebliebenen Karotten nach den Mahlzeiten]. Wenn es nicht genügend übriggebliebene Karotten gibt, wirst du alle übriggebliebenen Karotten essen, aber immer noch hungrig sein.\n\nBeispiel:\n* eat(5, 6, 10) -> [11, 4]\n* eat(4, 8, 9) -> [12, 1]\n* eat(1, 10, 10) -> [11, 0]\n* eat(2, 11, 5) -> [7, 0]\n\nVariablen:\n@number: integer\n    die Anzahl der Karotten, die du gegessen hast.\n@need: integer\n    die Anzahl der Karotten, die du essen musst.\n@remaining: integer\n    die Anzahl der übriggebliebenen Karotten, die im Lager vorhanden sind.\n\nEinschränkungen:\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n\nViel Spaß :)\"\"\"\n", "entry_point": "eat", "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"}
{"task_id": "HumanEval/149", "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"Schreiben Sie eine Funktion, die eine Liste von Zeichenketten als Parameter akzeptiert, die Zeichenketten mit ungerader Länge daraus löscht und die resultierende Liste in aufsteigender Reihenfolge zurückgibt. Die Liste ist immer eine Liste von Zeichenketten und niemals ein Array von Zahlen und kann Duplikate enthalten. Die Reihenfolge der Liste sollte nach der Länge jedes Wortes aufsteigend sein, und Sie sollten die Liste nach dieser Regel sortieren. Wenn zwei Wörter die gleiche Länge haben, sortieren Sie die Liste alphabetisch. Die Funktion sollte eine sortierte Liste von Zeichenketten zurückgeben. Sie dürfen davon ausgehen, dass alle Wörter die gleiche Länge haben. Zum Beispiel: assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"] assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\"\"\"\n", "entry_point": "sorted_list_sum", "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"}
{"task_id": "HumanEval/70", "prompt": "\ndef strange_sort_list(lst):\n    '''\n    Gegebene Liste von Ganzzahlen, geben Liste in seltsamer Reihenfolge zurück. Seltsame Sortierung ist, wenn Sie mit dem minimum Wert beginnen, dann mit dem maximum der verbleibenden Ganzzahlen, dann mit dem minimum und so weiter.\n\nBeispiele:\nstrange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\nstrange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\nstrange_sort_list([]) == []'''\n", "entry_point": "strange_sort_list", "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/134", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Erstellen Sie eine Funktion, die \"True\" zurückgibt, wenn das letzte Zeichen eines gegebenen Strings ein alphabetisches Zeichen ist und nicht Teil eines Wortes ist, andernfalls \"False\".\nHinweis: \"Wort\" ist eine Gruppe von Zeichen, die durch Leerzeichen getrennt sind.\n\nBeispiele:\ncheck_if_last_char_is_a_letter(\"apple pie\") ➞ False\ncheck_if_last_char_is_a_letter(\"apple pi e\") ➞ True\ncheck_if_last_char_is_a_letter(\"apple pi e \") ➞ False\ncheck_if_last_char_is_a_letter(\"\") ➞ False\n'''\n", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/71", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Gegeben die Längen der drei Seiten eines Dreiecks. Gibt den Flächeninhalt des Dreiecks zurück, auf 2 Dezimalstellen gerundet, wenn die drei Seiten ein gültiges Dreieck bilden. Andernfalls -1 zurückgeben. Drei Seiten bilden ein gültiges Dreieck, wenn die Summe von zwei Seiten größer ist als die dritte Seite. Beispiel: triangle_area(3, 4, 5) == 6.00 triangle_area(1, 2, 10) == -1'''\n", "entry_point": "triangle_area", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"}
{"task_id": "HumanEval/132", "prompt": "\ndef is_nested(string):\n    '''\n    Erstellen Sie eine Funktion, die einen String als Eingabe erhält, der nur eckige Klammern enthält.\nDie Funktion soll True zurückgeben, wenn und nur wenn es eine gültige Teilfolge von Klammern gibt, \nbei der mindestens eine Klammer in der Teilfolge verschachtelt ist.\n\nis_nested('[[]]') ➞ True\nis_nested('[]]]]]]][[[[[]') ➞ False\nis_nested('[][]') ➞ False\nis_nested('[]') ➞ False\nis_nested('[[][]]') ➞ True\nis_nested('[[]][[') ➞ True\n'''\n     '''\n", "entry_point": "is_nested", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"}
{"task_id": "HumanEval/92", "prompt": "\ndef any_int(x, y, z):\n    '''\n    Erstellen Sie eine Funktion, die 3 Zahlen akzeptiert.\n    Gibt true zurück, wenn eine der Zahlen gleich der Summe der anderen beiden ist, und alle Zahlen Ganzzahlen sind.\n    Gibt false in allen anderen Fällen zurück.\n    \n    Beispiele\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n'''\n", "entry_point": "any_int", "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/151", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Gegeben eine Liste von Zahlen, gib die Summe der Quadrate der Zahlen in der Liste zurück, die ungerade sind. Ignoriere Zahlen, die negativ sind oder keine ganzen Zahlen sind.\n\n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    Wenn die Eingabeliste leer ist, gib 0 zurück.'''\n", "entry_point": "double_the_difference", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"}
{"task_id": "HumanEval/136", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Erstelle eine Funktion, die ein Tupel (a, b) zurückgibt, wobei 'a' die größte der negativen Ganzzahlen ist und 'b' die kleinste der positiven Ganzzahlen in einer Liste ist. Wenn es keine negativen oder positiven Ganzzahlen gibt, gib sie als None zurück.\n\nBeispiele:\nlargest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\nlargest_smallest_integers([]) == (None, None)\nlargest_smallest_integers([0]) == (None, None)'''\n", "entry_point": "largest_smallest_integers", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"}
{"task_id": "HumanEval/125", "prompt": "\ndef split_words(txt):\n    '''\n    Bei einer Zeichenfolge von Wörtern soll eine Liste von Wörtern zurückgegeben werden, die nach Leerzeichen aufgeteilt sind. Wenn keine Leerzeichen im Text vorhanden sind, sollten sie durch Kommas ',' aufgeteilt werden. Wenn keine Kommas vorhanden sind, sollte die Anzahl der Kleinbuchstaben mit ungeradem Rang im Alphabet zurückgegeben werden, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\nBeispiele\nsplit_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\nsplit_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\nsplit_words(\"abcdef\") == 3 \n'''\n", "entry_point": "split_words", "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n", "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"}
{"task_id": "HumanEval/74", "prompt": "\ndef total_match(lst1, lst2):\n    '''\n    Schreiben Sie eine Funktion, die zwei Listen von Strings akzeptiert und die Liste zurückgibt, die insgesamt weniger Zeichen in allen Strings der Liste hat als die andere Liste.\n\nWenn die beiden Listen die gleiche Anzahl von Zeichen haben, geben Sie die erste Liste zurück.\n\nBeispiele\ntotal_match([], []) ➞ []\ntotal_match(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\ntotal_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\ntotal_match(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n'''\n", "entry_point": "total_match", "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"}
{"task_id": "HumanEval/69", "prompt": "\ndef search(lst):\n    '''\n    Du erhältst eine nicht leere Liste von positiven ganzen Zahlen. Gib die größte ganze Zahl zurück, die größer als null ist und eine Frequenz hat, die größer oder gleich dem Wert der Zahl selbst ist. Die Frequenz einer Zahl ist die Anzahl der Male, die sie in der Liste erscheint. Falls ein solcher Wert nicht existiert, gib -1 zurück.\nBeispiele:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1'''\n", "entry_point": "search", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"}
{"task_id": "HumanEval/119", "prompt": "\ndef match_parens(lst):\n    '''\n    Du erhältst eine Liste von zwei Zeichenfolgen, beide Zeichenfolgen bestehen ausschließlich aus öffnenden Klammern '(' oder schließenden Klammern ')' .\nDeine Aufgabe ist es zu überprüfen, ob es möglich ist, die beiden Zeichenfolgen in irgendeiner Reihenfolge zu verketten, so dass die resultierende Zeichenfolge gut ist.\nEine Zeichenfolge S gilt als gut, wenn und nur wenn alle Klammern in S ausgeglichen sind. Zum Beispiel: Die Zeichenfolge '(())()' ist gut, während die Zeichenfolge '())' es nicht ist.\nGib 'Ja' zurück, wenn es einen Weg gibt, eine gute Zeichenfolge zu erstellen, und gib andernfalls 'Nein' zurück.\n\nBeispiele:\nmatch_parens(['()(', ')']) == 'Ja'\nmatch_parens([')', ')']) == 'Nein'''\n", "entry_point": "match_parens", "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"}
{"task_id": "HumanEval/72", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Schreiben Sie eine Funktion, die True zurückgibt, wenn das Objekt q fliegt, und False sonst. Das Objekt q wird fliegen, wenn es ausgeglichen ist (es ist eine palindromische Liste) und die Summe seiner Elemente kleiner oder gleich dem maximal möglichen Gewicht w ist.\n\nBeispiel:\nwill_it_fly([1, 2], 5) ➞ False\n# 1+2 ist weniger als das maximal mögliche Gewicht, aber es ist unausgeglichen.\n\nwill_it_fly([3, 2, 3], 1) ➞ False\n# Es ist ausgeglichen, aber 3+2+3 ist mehr als das maximal mögliche Gewicht.\n\nwill_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3 ist weniger als das maximal mögliche Gewicht, und es ist ausgeglichen.\n\nwill_it_fly([3], 5) ➞ True\n# 3 ist weniger als das maximal mögliche Gewicht, und es ist ausgeglichen.'''\n", "entry_point": "will_it_fly", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"}
{"task_id": "HumanEval/99", "prompt": "\ndef closest_integer(value):\n    '''\n    Erstellen Sie eine Funktion, die einen Wert (String) repräsentierend eine Zahl akzeptiert und die dem Wert am nächsten liegende ganze Zahl zurückgibt. Wenn die Zahl genau zwischen zwei ganzen Zahlen liegt, runden Sie sie weg von Null.\n\nBeispiele\n>>> closest_integer(\"10\")\n10\n>>> closest_integer(\"15.3\")\n15\n\nHinweis:\nDas Runden weg von Null bedeutet, dass wenn die gegebene Zahl genau zwischen zwei ganzen Zahlen liegt, diejenige zurückgegeben werden soll, die am weitesten von Null entfernt ist. Zum Beispiel sollte closest_integer(\"14.5\") 15 zurückgeben und closest_integer(\"-14.5\") sollte -15 zurückgeben.\n'''\n", "entry_point": "closest_integer", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"}
{"task_id": "HumanEval/157", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Gegeben sind die Längen der drei Seiten eines Dreiecks. Gib True zurück, wenn die drei Seiten ein rechtwinkliges Dreieck bilden, andernfalls False.\nEin rechtwinkliges Dreieck ist ein Dreieck, bei dem ein Winkel ein rechter Winkel oder 90 Grad ist.\nBeispiel:\nright_angle_triangle(3, 4, 5) == True\nright_angle_triangle(1, 2, 3) == False\n'''\n", "entry_point": "right_angle_triangle", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"}
{"task_id": "HumanEval/126", "prompt": "\ndef is_sorted(lst):\n    '''\n    ```\nGegeben eine Liste von Zahlen, geben Sie zurück, ob sie in aufsteigender Reihenfolge sortiert sind. Wenn die Liste mehr als 1 Duplikat derselben Zahl enthält, geben Sie False zurück. Nehmen Sie an, dass keine negativen Zahlen und nur Ganzzahlen vorhanden sind.\n\nBeispiele\nis_sorted([5]) ➞ True\nis_sorted([1, 2, 3, 4, 5]) ➞ True\nis_sorted([1, 3, 2, 4, 5]) ➞ False\nis_sorted([1, 2, 3, 4, 5, 6]) ➞ True\nis_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True\nis_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False\nis_sorted([1, 2, 2, 3, 3, 4]) ➞ True\nis_sorted([1, 2, 2, 2, 3, 4]) ➞ False\n```'''\n", "entry_point": "is_sorted", "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"}
{"task_id": "HumanEval/148", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    Es gibt acht Planeten in unserem Sonnensystem: Der dem Sonne am nächsten ist Merkur, der nächste ist Venus, dann Erde, Mars, Jupiter, Saturn, Uranus, Neptun.\nSchreibe eine Funktion, die zwei Planetennamen als Zeichenketten `planet1` und `planet2` annimmt. Die Funktion sollte ein Tupel zurückgeben, das alle Planeten enthält, deren Umlaufbahnen zwischen der Umlaufbahn von `planet1` und der Umlaufbahn von `planet2` liegen, sortiert nach der Nähe zur Sonne. Die Funktion sollte ein leeres Tupel zurückgeben, wenn `planet1` oder `planet2` keine korrekten Planetennamen sind.\nBeispiele\n`bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")`\n`bf(\"Earth\", \"Mercury\") ==> (\"Venus\")`\n`bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")`'''\n", "entry_point": "bf", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"}
{"task_id": "HumanEval/77", "prompt": "\ndef iscube(a):\n    '''\n    Schreiben Sie eine Funktion, die eine ganze Zahl a entgegennimmt und True zurückgibt, wenn diese ganze Zahl die Kubik einer bestimmten ganzen Zahl ist.\nHinweis: Sie können davon ausgehen, dass die Eingabe immer gültig ist.\nBeispiele:\niscube(1) ==> True\niscube(2) ==> False\niscube(-1) ==> True\niscube(64) ==> True\niscube(0) ==> True\niscube(180) ==> False'''\n", "entry_point": "iscube", "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"}

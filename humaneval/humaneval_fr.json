{"task_id": "HumanEval/16", "prompt": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"Donnée une chaîne de caractères, déterminez combien de caractères distincts (indépendamment de la casse) elle contient.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\"\"\"\n", "entry_point": "count_distinct_characters", "canonical_solution": "    return len(set(string.lower()))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n"}
{"task_id": "HumanEval/3", "prompt": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"Vous recevez une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là la fonction doit retourner Vrai. Sinon, elle doit retourner Faux.\n>>> below_zero([1, 2, 3])\nFaux\n>>> below_zero([1, 2, -4, 5])\nVrai\"\"\"\n", "entry_point": "below_zero", "canonical_solution": "    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n"}
{"task_id": "HumanEval/0", "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Vérifiez s'il existe dans une liste de nombres donnée deux nombres plus proches l'un de l'autre que la valeur seuil donnée.\n    >>> a_des_elements_proches([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> a_des_elements_proches([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\"\"\"\n", "entry_point": "has_close_elements", "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n"}
{"task_id": "HumanEval/9", "prompt": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"À partir d'une liste donnée d'entiers, générer une liste de l'élément maximum roulant trouvé jusqu'à un moment donné dans la séquence.>>> rolling_max([1, 2, 3, 2, 3, 4, 2])[1, 2, 3, 3, 3, 4, 4]\"\"\"\n", "entry_point": "rolling_max", "canonical_solution": "    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n"}
{"task_id": "HumanEval/5", "prompt": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"Insérez un nombre 'delimeter' entre chaque deux éléments consécutifs de la liste d'entrée `numbers'\n    \n    >>> intersperser([], 4)\n    []\n    >>> intersperser([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\"\"\"\n", "entry_point": "intersperse", "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n"}
{"task_id": "HumanEval/23", "prompt": "\n\ndef strlen(string: str) -> int:\n    \"\"\"Retourne la longueur de la chaîne donnée\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n", "entry_point": "strlen", "canonical_solution": "    return len(string)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n"}
{"task_id": "HumanEval/2", "prompt": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"Donné un nombre flottant positif, il peut être décomposé en une partie entière (plus grand entier inférieur au nombre donné) et en décimales (partie restante toujours inférieure à 1).\n\nRenvoyez la partie décimale du nombre.\n>>> truncate_number(3.5)\n0.5\"\"\"\n", "entry_point": "truncate_number", "canonical_solution": "    return number % 1.0\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n"}
{"task_id": "HumanEval/11", "prompt": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"Les entrées sont deux chaînes de caractères a et b ne contenant que des 1 et des 0.\nEffectuez un XOR binaire sur ces entrées et renvoyez également le résultat sous forme de chaîne de caractères.\n>>> string_xor('010', '110')\n'100'\"\"\"\n", "entry_point": "string_xor", "canonical_solution": "    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n"}
{"task_id": "HumanEval/13", "prompt": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"Renvoyer un plus grand diviseur commun de deux entiers a et b\n    >>> plus_grand_diviseur_commun(3, 5)\n    1\n    >>> plus_grand_diviseur_commun(25, 15)\n    5\n    \"\"\"\n", "entry_point": "greatest_common_divisor", "canonical_solution": "    while b:\n        a, b = b, a % b\n    return a\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n"}
{"task_id": "HumanEval/4", "prompt": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"Pour une liste donnée de nombres d'entrée, calculez l'écart absolu moyen par rapport à la moyenne de cet ensemble de données.\nL'écart absolu moyen est la différence absolue moyenne entre chaque élément et un point central (la moyenne dans ce cas) :\nMAD = moyenne | x - x_mean |\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0\"\"\"\n", "entry_point": "mean_absolute_deviation", "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n\n"}
{"task_id": "HumanEval/14", "prompt": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"Retourne la liste de tous les préfixes du plus court au plus long de la chaîne d'entrée\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\"\"\"\n", "entry_point": "all_prefixes", "canonical_solution": "    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n"}
{"task_id": "HumanEval/24", "prompt": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"Pour un nombre donné n, trouver le plus grand nombre qui divise n de manière égale, plus petit que n\n    >>>plus_grand_diviseur(15)\n    5\"\"\"\n", "entry_point": "largest_divisor", "canonical_solution": "    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n"}
{"task_id": "HumanEval/12", "prompt": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\"Du liste de chaînes, retournez la plus longue. Retournez la première si plusieurs chaînes ont la même longueur. Retournez None si la liste d'entrée est vide.\"\"\"\n", "entry_point": "longest", "canonical_solution": "    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n"}
{"task_id": "HumanEval/10", "prompt": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\"Testez si la chaîne donnée est un palindrome.\"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n", "entry_point": "make_palindrome", "canonical_solution": "    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n"}
{"task_id": "HumanEval/7", "prompt": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"Filtrer une liste d'entrée de chaînes de caractères uniquement pour celles qui contiennent une sous-chaîne donnée\n>>> filter_by_substring([], 'a')\n[]\n>>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n['abc', 'bacd', 'array']\"\"\"\n", "entry_point": "filter_by_substring", "canonical_solution": "    return [x for x in strings if substring in x]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n"}
{"task_id": "HumanEval/6", "prompt": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"Les entrées de cette fonction sont une chaîne de caractères représentant plusieurs groupes de parenthèses imbriquées, séparées par des espaces.\nPour chacun des groupes, renvoyer le niveau le plus profond d'imbrication des parenthèses.\nPar exemple, (()()) a un maximum de deux niveaux d'imbrication, tandis que ((())) en a trois.\n\n>>> parse_nested_parens('(()()) ((())) () ((())()())')\n[2, 3, 1, 3]\"\"\"\n", "entry_point": "parse_nested_parens", "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n"}
{"task_id": "HumanEval/8", "prompt": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"Pour une liste donnée d'entiers, renvoyez un tuple composé de la somme et du produit de tous les entiers de la liste.\nLa somme vide doit être égale à 0 et le produit vide doit être égal à 1.\n>>> sum_product([])\n(0, 1)\n>>> sum_product([1, 2, 3, 4])\n(10, 24)\"\"\"\n", "entry_point": "sum_product", "canonical_solution": "    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n"}
{"task_id": "HumanEval/15", "prompt": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"Renvoie une chaîne de caractères contenant des nombres séparés par des espaces, commençant par 0 et allant jusqu'à n inclus.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\"\"\"\n", "entry_point": "string_sequence", "canonical_solution": "    return ' '.join([str(x) for x in range(n + 1)])\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n"}
{"task_id": "HumanEval/18", "prompt": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\"Trouvez combien de fois une sous-chaîne donnée peut être trouvée dans la chaîne d'origine. Comptez les cas de chevauchement.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\"\"\"\n", "entry_point": "how_many_times", "canonical_solution": "    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n"}
{"task_id": "HumanEval/22", "prompt": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"Filtrer la liste donnée de toutes les valeurs Python uniquement pour les entiers\n    >>> filtrer_entiers(['a', 3.14, 5])\n    [5]\n    >>> filtrer_entiers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\"\"\"\n", "entry_point": "filter_integers", "canonical_solution": "    return [x for x in values if isinstance(x, int)]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n"}
{"task_id": "HumanEval/19", "prompt": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"L'entrée est une chaîne de caractères séparées par des espaces, contenant des chiffres allant de 'zéro' à 'neuf'.\n    Les choix valides sont 'zéro', 'un', 'deux', 'trois', 'quatre', 'cinq', 'six', 'sept', 'huit' et 'neuf'.\n    Renvoyer la chaîne avec les chiffres triés du plus petit au plus grand.\n    >>> sort_numbers('trois un cinq')\n    'un trois cinq'\n    \"\"\"\n", "entry_point": "sort_numbers", "canonical_solution": "    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n"}
{"task_id": "HumanEval/108", "prompt": "\ndef count_nums(arr):\n    \"\"\"Écrivez une fonction count_nums qui prend un tableau d'entiers et renvoie le nombre d'éléments dont la somme des chiffres est supérieure à 0.\nSi un nombre est négatif, alors son premier chiffre signé sera négatif:\npar exemple, -123 a des chiffres signés -1, 2 et 3.\n>>> count_nums([]) == 0\n>>> count_nums([-1, 11, -11]) == 1\n>>> count_nums([1, 1, 2]) == 3\"\"\"\n", "entry_point": "count_nums", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/138", "prompt": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Évaluez si le nombre donné n peut être écrit comme la somme de exactement 4 nombres pairs positifs\n    Exemple\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n    \"\"\"\n", "entry_point": "is_equal_to_sum_even", "canonical_solution": "    return n%2 == 0 and n >= 8\n", "test": "def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n"}
{"task_id": "HumanEval/1", "prompt": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"L'entrée de cette fonction est une chaîne de caractères contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de séparer ces groupes en différentes chaînes de caractères et de renvoyer la liste de ces groupes.\nLes groupes séparés sont équilibrés (chaque ouverture de parenthèse est correctement fermée) et ne sont pas imbriqués les uns dans les autres \nIgnorez les espaces dans la chaîne d'entrée.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']\"\"\"\n", "entry_point": "separate_paren_groups", "canonical_solution": "    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n"}
{"task_id": "HumanEval/25", "prompt": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\"Renvoie une liste des facteurs premiers de l'entier donné dans l'ordre du plus petit au plus grand.\nChacun des facteurs doit être listé un certain nombre de fois correspondant à combien de fois il apparaît dans la factorisation.\nLe nombre d'entrée doit être égal au produit de tous les facteurs\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\"\"\"\n", "entry_point": "factorize", "canonical_solution": "    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n"}
{"task_id": "HumanEval/21", "prompt": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"Donnée une liste de nombres (d'au moins deux éléments), applique une transformation linéaire à cette liste, de telle sorte que le nombre le plus petit devienne 0 et le plus grand devienne 1\n    >>> rescale_to_unit ([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\"\"\"\n", "entry_point": "rescale_to_unit", "canonical_solution": "    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) / (max_number - min_number) for x in numbers]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n"}
{"task_id": "HumanEval/17", "prompt": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"L'entrée de cette fonction est une chaîne de caractères représentant des notes de musique dans un format ASCII spécial. Votre tâche consiste à analyser cette chaîne et à renvoyer une liste d'entiers correspondant au nombre de temps durant lesquels chaque note dure. Voici une légende :\n'o' - note entière, durée de quatre temps\n'o|' - demi-note, durée de deux temps\n'.|' - quart de note, durée d'un temps\n\n>>> parse_music('o o| .| o| o| .| .| .| .| o o')\n[4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\"\"\"\n", "entry_point": "parse_music", "canonical_solution": "    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n"}
{"task_id": "HumanEval/146", "prompt": "\ndef specialFilter(nums):\n    \"\"\"Écrivez une fonction qui prend un tableau de nombres en entrée et retourne le nombre d'éléments dans le tableau qui sont supérieurs à 10 et dont le premier et le dernier chiffre d'un nombre sont impairs (1, 3, 5, 7, 9).\nPar exemple:\nspecialFilter([15, -73, 14, -15]) => 1\nspecialFilter([33, -2, -3, 45, 21, 109]) => 2\"\"\"\n", "entry_point": "specialFilter", "canonical_solution": "    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n"}
{"task_id": "HumanEval/147", "prompt": "\ndef get_max_triples(n):\n    \"\"\"Vous obtenez un entier positif n. Vous devez créer un tableau d'entiers a de longueur n.\n        Pour chaque i (1 ≤ i ≤ n), la valeur de a[i] = i * i - i + 1.\n        Renvoyez le nombre de triplets (a[i], a[j], a[k]) de a où i < j < k, \n    et a[i] + a[j] + a[k] est un multiple de 3.\n\n    Exemple :\n        Entrée: n = 5\n        Sortie: 1\n        Explication: \n        a = [1, 3, 7, 13, 21]\n        Le seul triplet valide est (1, 7, 13).\"\"\"\n", "entry_point": "get_max_triples", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n", "test": "def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n"}
{"task_id": "HumanEval/38", "prompt": "\n\ndef encode_cyclic(s: str):\n    \"\"\"renvoie la chaîne encodée en faisant circuler des groupes de trois caractères.\"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n", "entry_point": "decode_cyclic", "canonical_solution": "    return encode_cyclic(encode_cyclic(s))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n"}
{"task_id": "HumanEval/64", "prompt": "\nFIX = \"\"\"Ajouter plus de cas de test.\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n", "entry_point": "vowels_count", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/50", "prompt": "\n\ndef encode_shift(s: str):\n    \"\"\"retourne une chaîne encodée en déplaçant chaque caractère de 5 dans l'alphabet.\"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n", "entry_point": "decode_shift", "canonical_solution": "    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n"}
{"task_id": "HumanEval/55", "prompt": "\n\ndef fib(n: int):\n    \"\"\"Retourne le n-ième nombre de Fibonacci.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\"\"\"\n", "entry_point": "fib", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n"}
{"task_id": "HumanEval/48", "prompt": "\n\ndef is_palindrome(text: str):\n    \"\"\"Vérifie si la chaîne donnée est un palindrome\n    >>> est_palindrome('')\n    Vrai\n    >>> est_palindrome('aba')\n    Vrai\n    >>> est_palindrome('aaaaa')\n    Vrai\n    >>> est_palindrome('zbcd')\n    Faux\"\"\"\n", "entry_point": "is_palindrome", "canonical_solution": "    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n"}
{"task_id": "HumanEval/53", "prompt": "\n\ndef add(x: int, y: int):\n    \"\"\"Ajouter deux nombres x et y\n    >>> ajouter(2, 3)\n    5\n    >>> ajouter(5, 7)\n    12\"\"\"\n", "entry_point": "add", "canonical_solution": "    return x + y\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n"}
{"task_id": "HumanEval/45", "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"Donné la longueur d'un côté et le retour haute area pour un triangle.\n# triangle_area(5, 3)\n= 7.5\"\"\"\n", "entry_point": "triangle_area", "canonical_solution": "    return a * h / 2.0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n"}
{"task_id": "HumanEval/32", "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"Évalue le polynôme avec les coefficients xs au point x.\nretourne xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n", "entry_point": "find_zero", "canonical_solution": "    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n"}
{"task_id": "HumanEval/83", "prompt": "\ndef starts_one_ends(n):\n    \"\"\"Étant donné un entier positif n, renvoyez le nombre de nombres entiers positifs à n chiffres qui commencent ou se terminent par 1.\"\"\"\n", "entry_point": "starts_one_ends", "canonical_solution": "    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/75", "prompt": "\ndef is_multiply_prime(a):\n    \"\"\"Écrivez une fonction qui renvoie vrai si le nombre donné est le produit de 3 nombres premiers\net faux sinon.\nSachant que (a) est inférieur à 100.\nExemple:\nis_multiply_prime(30) == True\n30 = 2 * 3 * 5\"\"\"\n", "entry_point": "is_multiply_prime", "canonical_solution": "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n", "test": "def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n"}
{"task_id": "HumanEval/34", "prompt": "\n\ndef unique(l: list):\n    \"\"\"Renvoyer les éléments uniques triés dans une liste\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "entry_point": "unique", "canonical_solution": "    return sorted(list(set(l)))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n"}
{"task_id": "HumanEval/42", "prompt": "\n\ndef incr_list(l: list):\n    \"\"\"Renvoyer une liste avec des éléments incrémentés de 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n", "entry_point": "incr_list", "canonical_solution": "    return [(e + 1) for e in l]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n"}
{"task_id": "HumanEval/28", "prompt": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"Concaténer une liste de chaînes de caractères en une seule chaîne\n     >>> concaténer([])\n     ''\n     >>> concaténer(['a', 'b', 'c'])\n     'abc'\"\"\"\n", "entry_point": "concatenate", "canonical_solution": "    return ''.join(strings)\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n"}
{"task_id": "HumanEval/59", "prompt": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Renvoyer le plus grand facteur premier de n. Supposer que n > 1 et n'est pas un nombre premier.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n", "entry_point": "largest_prime_factor", "canonical_solution": "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n"}
{"task_id": "HumanEval/39", "prompt": "\n\ndef prime_fib(n: int):\n    \"\"\"prime_fib renvoie le nombre n-ième qui est à la fois un nombre de Fibonacci et un nombre premier.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\"\"\"\n", "entry_point": "prime_fib", "canonical_solution": "    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n"}
{"task_id": "HumanEval/27", "prompt": "\n\ndef flip_case(string: str) -> str:\n    \"\"\"Pour une chaîne donnée, inverser les caractères minuscules en majuscules et les caractères majuscules en minuscules.\n    \n    >>> flip_case('Hello')\n    'hELLO'\"\"\"\n", "entry_point": "flip_case", "canonical_solution": "    return string.swapcase()\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n"}
{"task_id": "HumanEval/131", "prompt": "\ndef digits(n):\n    \"\"\"Étant donné un entier positif n, retournez le produit des chiffres impairs.\n    Retournez 0 si tous les chiffres sont pairs.\n    Par exemple:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\"\"\"\n", "entry_point": "digits", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n"}
{"task_id": "HumanEval/47", "prompt": "\n\ndef median(l: list):\n    \"\"\"Retourne la médiane des éléments dans la liste l.\n    >>> médiane([3, 1, 2, 4, 5])\n    3\n    >>> médiane([-10, 4, 6, 1000, 10, 20])\n    15.0\"\"\"\n", "entry_point": "median", "canonical_solution": "    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n"}
{"task_id": "HumanEval/36", "prompt": "\n\ndef fizz_buzz(n: int):\n    \"\"\"Renvoyer le nombre de fois où le chiffre 7 apparaît dans les entiers inférieurs à n qui sont divisibles par 11 ou 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n", "entry_point": "fizz_buzz", "canonical_solution": "    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n"}
{"task_id": "HumanEval/29", "prompt": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"Filtrer une liste d'entrée de chaînes de caractères uniquement pour celles qui commencent par un préfixe donné.\n>>> filter_by_prefix([], 'a')\n[]\n>>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n['abc', 'array']\"\"\"\n", "entry_point": "filter_by_prefix", "canonical_solution": "    return [x for x in strings if x.startswith(prefix)]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n"}
{"task_id": "HumanEval/65", "prompt": "\ndef circular_shift(x, shift):\n    \"\"\"Décalez circulairement les chiffres de l'entier x, décalez les chiffres vers la droite par shift et renvoyez le résultat sous forme de chaîne de caractères.\nSi shift > nombre de chiffres, renvoyez les chiffres inversés.\n>>> circular_shift(12, 1)\n\"21\"\n>>> circular_shift(12, 2)\n\"12\"\"\"\n", "entry_point": "circular_shift", "canonical_solution": "    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/150", "prompt": "\ndef x_or_y(n, x, y):\n    \"\"\"Un programme simple qui doit renvoyer la valeur de x si n est un nombre premier et doit renvoyer la valeur de y sinon.\n\nExemples:\npour x_or_y(7, 34, 12) == 34\npour x_or_y(15, 8, 5) == 5\"\"\"\n", "entry_point": "x_or_y", "canonical_solution": "    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n"}
{"task_id": "HumanEval/37", "prompt": "\n\ndef sort_even(l: list):\n    \"\"\"Cette fonction prend une liste l et renvoie une liste l' telle que l' est identique à l aux indices impairs, tandis que ses valeurs aux indices pairs sont égales aux valeurs des indices pairs de l, mais triées.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\"\"\"\n", "entry_point": "sort_even", "canonical_solution": "    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n"}
{"task_id": "HumanEval/85", "prompt": "\ndef add(lst):\n    \"\"\"Donné une liste non vide d'entiers lst. ajoutez les éléments pairs qui se trouvent aux indices impairs.\n\n    Exemples:\n        add([4, 2, 6, 7]) ==> 2\"\"\"\n", "entry_point": "add", "canonical_solution": "    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n"}
{"task_id": "HumanEval/52", "prompt": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Renvoie True si tous les nombres de la liste l sont inférieurs au seuil t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\"\"\"\n", "entry_point": "below_threshold", "canonical_solution": "    for e in l:\n        if e >= t:\n            return False\n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n"}
{"task_id": "HumanEval/51", "prompt": "\n\ndef remove_vowels(text):\n    \"\"\"remove_vowels est une fonction qui prend une chaîne de caractères et renvoie une chaîne de caractères sans voyelles.\n>>> remove_vowels('')\n''\n>>> remove_vowels(\"abcdef\\nghijklm\")\n'bcdf\\nghjklm'\n>>> remove_vowels('abcdef')\n'bcdf'\n>>> remove_vowels('aaaaa')\n''\n>>> remove_vowels('aaBAA')\n'B'\n>>> remove_vowels('zbcd')\n'zbcd'\"\"\"\n", "entry_point": "remove_vowels", "canonical_solution": "    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n"}
{"task_id": "HumanEval/60", "prompt": "\n\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n est une fonction qui fait la somme des nombres de 1 à n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n", "entry_point": "sum_to_n", "canonical_solution": "    return sum(range(n + 1))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n"}
{"task_id": "HumanEval/56", "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets est une chaîne de caractères de \"<\" et \">\".\n    Renvoie True si chaque crochet d'ouverture a un crochet de fermeture correspondant.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\"\"\"\n", "entry_point": "correct_bracketing", "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n"}
{"task_id": "HumanEval/57", "prompt": "\n\ndef monotonic(l: list):\n    \"\"\"Renvoie True si les éléments de la liste sont monotones croissants ou décroissants.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n", "entry_point": "monotonic", "canonical_solution": "    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n"}
{"task_id": "HumanEval/102", "prompt": "\ndef choose_num(x, y):\n    \"\"\"Cette fonction prend deux nombres positifs x et y et renvoie le plus grand nombre entier pair qui se trouve dans l'intervalle [x, y] inclusif. Si aucun nombre ne correspond à cette condition, alors la fonction doit renvoyer -1.\n\nPar exemple :\nchoose_num(12, 15) = 14\nchoose_num(13, 12) = -1\n\"\"\"\n", "entry_point": "choose_num", "canonical_solution": "    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n"}
{"task_id": "HumanEval/35", "prompt": "\n\ndef max_element(l: list):\n    \"\"\"Renvoie l'élément maximum dans la liste.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n", "entry_point": "max_element", "canonical_solution": "    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n"}
{"task_id": "HumanEval/121", "prompt": "\ndef solution(lst):\n    \"\"\"Étant donné une liste non vide d'entiers, retournez la somme de tous les éléments impairs qui se trouvent à des positions paires.\n\nExemples\nsolution([5, 8, 7, 1]) ==> 12\nsolution([3, 3, 3, 3, 3]) ==> 9\nsolution([30, 13, 24, 321]) ==>0\"\"\"\n", "entry_point": "solution", "canonical_solution": "    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n"}
{"task_id": "HumanEval/93", "prompt": "\ndef encode(message):\n    \"\"\"Écrivez une fonction qui prend un message et le encode de manière à échanger la casse de toutes les lettres, à remplacer toutes les voyelles du message par la lettre qui apparaît 2 positions plus loin dans l'alphabet anglais.\nSupposez seulement des lettres.\n\nExemples :\n>>> encode('test')\n'TGST'\n>>> encode('This is a message')\n'tHKS KS C MGSSCGG'\"\"\"\n", "entry_point": "encode", "canonical_solution": "    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/61", "prompt": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"brackets est une chaîne de caractères \"(\" et \")\".\n    renvoyer True si chaque parenthèse ouvrante a une parenthèse fermante correspondante.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\"\"\"\n", "entry_point": "correct_bracketing", "canonical_solution": "    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n"}
{"task_id": "HumanEval/58", "prompt": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Renvoyer les éléments communs uniques et triés de deux listes.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n", "entry_point": "common", "canonical_solution": "    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n"}
{"task_id": "HumanEval/44", "prompt": "\n\ndef change_base(x: int, base: int):\n    \"\"\"Changer la base numérique du numéro d'entrée x en base.\n    renvoyer la représentation sous forme de chaîne après la conversion.\n    les nombres de base sont inférieurs à 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n", "entry_point": "change_base", "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n"}
{"task_id": "HumanEval/97", "prompt": "\ndef multiply(a, b):\n    \"\"\"Complétez la fonction qui prend deux entiers et renvoie le produit de leurs chiffres unitaires. Supposons que l'entrée soit toujours valide. Exemples : multiply(148, 412) doit renvoyer 16. multiply(19, 28) doit renvoyer 72. multiply(2020, 1851) doit renvoyer 0. multiply(14,-15) doit renvoyer 20.\"\"\"\n", "entry_point": "multiply", "canonical_solution": "    return abs(a % 10) * abs(b % 10)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n"}
{"task_id": "HumanEval/62", "prompt": "\n\ndef derivative(xs: list):\n    \"\"\"xs représentent les coefficients d'un polynôme.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Retourne la dérivée de ce polynôme sous la même forme.\n    >>> dérivée([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> dérivée([1, 2, 3])\n    [2, 6]\"\"\"\n", "entry_point": "derivative", "canonical_solution": "    return [(i * x) for i, x in enumerate(xs)][1:]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n"}
{"task_id": "HumanEval/104", "prompt": "\ndef unique_digits(x):\n    \"\"\"Donné une liste de nombres entiers positifs x. retourner une liste triée de tous les éléments qui n'ont pas de chiffre pair.\n\nNote: La liste retournée doit être triée dans l'ordre croissant.\n\nPar exemple:\n>>> unique_digits([15, 33, 1422, 1])\n[1, 15, 33]\n>>> unique_digits([152, 323, 1422, 10])\n[]\"\"\"\n", "entry_point": "unique_digits", "canonical_solution": "    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/49", "prompt": "\n\ndef modp(n: int, p: int):\n    \"\"\"Retourne 2^n modulo p (attention aux numériques).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\"\"\"\n", "entry_point": "modp", "canonical_solution": "    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n"}
{"task_id": "HumanEval/98", "prompt": "\ndef count_upper(s):\n    \"\"\"Étant donné une chaîne de caractères s, comptez le nombre de voyelles majuscules aux indices pairs. \n    Par exemple: \n    count_upper('aBCdEf') retourne 1\n    count_upper('abcdefg') retourne 0\n    count_upper('dBBE') retourne 0\"\"\"\n", "entry_point": "count_upper", "canonical_solution": "    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/31", "prompt": "\n\ndef is_prime(n):\n    \"\"\"Renvoyez vrai si un nombre donné est premier, sinon renvoyez faux.\n    >>> est_premier(6)\n    Faux\n    >>> est_premier(101)\n    Vrai\n    >>> est_premier(11)\n    Vrai\n    >>> est_premier(13441)\n    Vrai\n    >>> est_premier(61)\n    Vrai\n    >>> est_premier(4)\n    Faux\n    >>> est_premier(1)\n    Faux\"\"\"\n", "entry_point": "is_prime", "canonical_solution": "    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n"}
{"task_id": "HumanEval/135", "prompt": "\ndef can_arrange(arr):\n    \"\"\"Créez une fonction qui renvoie l'index le plus grand d'un élément qui n'est pas plus grand ou égal à l'élément immédiatement précédent. Si aucun tel élément n'existe, renvoyez -1. Le tableau donné ne contiendra pas de valeurs en double.\n\nExemples :\ncan_arrange([1,2,4,3,5]) = 3\ncan_arrange([1,2,3]) = -1\"\"\"\n", "entry_point": "can_arrange", "canonical_solution": "    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n"}
{"task_id": "HumanEval/82", "prompt": "\ndef prime_length(string):\n    \"\"\"Écrivez une fonction qui prend une chaîne de caractères et renvoie True si la longueur de la chaîne est un nombre premier, sinon renvoie False.\nExemples\nprime_length('Hello') == True\nprime_length('abcdcba') == True\nprime_length('kittens') == True\nprime_length('orange') == False\"\"\"\n", "entry_point": "prime_length", "canonical_solution": "    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n"}
{"task_id": "HumanEval/122", "prompt": "\ndef add_elements(arr, k):\n    \"\"\"Donné un tableau non vide d'entiers arr et un entier k, renvoie la somme des éléments ayant au plus deux chiffres parmi les premiers k éléments de arr.\n\nExemple:\n\n    Entrée: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n    Sortie: 24 # somme de 21 + 3\n\nContraintes:\n    1. 1 <= len(arr) <= 100\n    2. 1 <= k <= len(arr)\"\"\"\n", "entry_point": "add_elements", "canonical_solution": "    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/84", "prompt": "\ndef solve(N):\n    \"\"\"Étant donné un entier positif N, retournez la somme totale de ses chiffres en binaire.\n\n    Exemple\n        Pour N = 1000, la somme des chiffres sera 1, le résultat devrait être \"1\".\n        Pour N = 150, la somme des chiffres sera 6, le résultat devrait être \"110\".\n        Pour N = 147, la somme des chiffres sera 12, le résultat devrait être \"1100\".\n\n    Variables:\n        @N entier\n             Contraintes: 0 ≤ N ≤ 10000.\n    Sortie:\n         une chaîne de caractères représentant un nombre binaire\n    \"\"\"\n", "entry_point": "solve", "canonical_solution": "    return bin(sum(int(i) for i in str(N)))[2:]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n"}
{"task_id": "HumanEval/30", "prompt": "\n\ndef get_positive(l: list):\n    \"\"\"Retournez seulement les numéros positifs dans la liste.\n    >>> obtenir_positifs([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> obtenir_positifs([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\"\"\"\n", "entry_point": "get_positive", "canonical_solution": "    return [e for e in l if e > 0]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n"}
{"task_id": "HumanEval/114", "prompt": "\ndef minSubArraySum(nums):\n    \"\"\"Étant donné un tableau d'entiers nums, trouvez la somme minimale de n'importe quel sous-tableau non vide de nums.\nExemple\nminSubArraySum([2, 3, 4, 1, 2, 4]) == 1\nminSubArraySum([-1, -2, -3]) == -6\"\"\"\n", "entry_point": "minSubArraySum", "canonical_solution": "    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n"}
{"task_id": "HumanEval/142", "prompt": "\n\n\ndef sum_squares(lst):\n    \"\"\"Cette fonction prendra une liste d'entiers. Pour toutes les entrées de la liste, la fonction élèvera au carré l'entrée entière si son indice est un multiple de 3 et élèvera au cube l'entrée entière si son indice est un multiple de 4 et n'est pas un multiple de 3. La fonction ne modifiera pas les entrées de la liste dont les indices ne sont pas un multiple de 3 ou de 4. La fonction renverra ensuite la somme de toutes les entrées.\n\nExemples :\nPour lst = [1,2,3], la sortie devrait être 6\nPour lst = [], la sortie devrait être 0\nPour lst = [-1,-5,2,-1,-5], la sortie devrait être -126\"\"\"\n", "entry_point": "sum_squares", "canonical_solution": "    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n"}
{"task_id": "HumanEval/89", "prompt": "\ndef encrypt(s):\n    \"\"\"Créez une fonction encrypt qui prend une chaîne de caractères en argument et retourne une chaîne de caractères chiffrée avec une rotation de l'alphabet. L'alphabet doit être tourné de manière que les lettres se déplacent vers le bas de deux fois deux places. Par exemple: encrypt('hi') retourne 'lm' encrypt('asdfghjkl') retourne 'ewhjklnop' encrypt('gf') retourne 'kj' encrypt('et') retourne 'ix'\"\"\"\n", "entry_point": "encrypt", "canonical_solution": "    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/79", "prompt": "\ndef decimal_to_binary(decimal):\n    \"\"\"Vous recevrez un nombre sous forme décimale et votre tâche sera de le convertir en format binaire. La fonction doit renvoyer une chaîne de caractères, chaque caractère représentant un nombre binaire. Chaque caractère dans la chaîne sera '0' ou '1'.\n\nIl y aura deux caractères supplémentaires 'db' au début et à la fin de la chaîne. Les caractères supplémentaires sont là pour aider avec le format.\n\nExemples :\ndecimal_to_binary(15)   # renvoie \"db1111db\"\ndecimal_to_binary(32)   # renvoie \"db100000db\"\"\"\n", "entry_point": "decimal_to_binary", "canonical_solution": "    return \"db\" + bin(decimal)[2:] + \"db\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/66", "prompt": "\ndef digitSum(s):\n    \"\"\"Tâche\nÉcrivez une fonction qui prend une chaîne de caractères en entrée et renvoie la somme des codes ASCII des caractères majuscules seulement.\n\nExemples :\ndigitSum(\"\") => 0\ndigitSum(\"abAB\") => 131\ndigitSum(\"abcCd\") => 67\ndigitSum(\"helloE\") => 69\ndigitSum(\"woArBld\") => 131\ndigitSum(\"aAaaaXa\") => 153\"\"\"\n", "entry_point": "digitSum", "canonical_solution": "    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n"}
{"task_id": "HumanEval/26", "prompt": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"À partir d'une liste d'entiers, supprimez tous les éléments qui se produisent plus d'une fois.\nGardez l'ordre des éléments tel quel dans l'entrée.\n>>> remove_duplicates([1, 2, 3, 2, 4])\n[1, 3, 4]\"\"\"\n", "entry_point": "remove_duplicates", "canonical_solution": "    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n"}
{"task_id": "HumanEval/54", "prompt": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"Vérifiez si deux mots ont les mêmes caractères.\n>>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\nTrue\n>>> same_chars('abcd', 'dddddddabc')\nTrue\n>>> same_chars('dddddddabc', 'abcd')\nTrue\n>>> same_chars('eabcd', 'dddddddabc')\nFalse\n>>> same_chars('abcd', 'dddddddabce')\nFalse\n>>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\nFalse\"\"\"\n", "entry_point": "same_chars", "canonical_solution": "    return set(s0) == set(s1)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n"}
{"task_id": "HumanEval/43", "prompt": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"La fonction pairs_sum_to_zero prend en entrée une liste d'entiers.\nElle renvoie True s'il y a deux éléments distincts dans la liste qui se cumulent à zéro, et False sinon.\n>>> pairs_sum_to_zero([1, 3, 5, 0])\nFalse\n>>> pairs_sum_to_zero([1, 3, -2, 1])\nFalse\n>>> pairs_sum_to_zero([1, 2, 3, 7])\nFalse\n>>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\nTrue\n>>> pairs_sum_to_zero([1])\nFalse\"\"\"\n", "entry_point": "pairs_sum_to_zero", "canonical_solution": "    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n"}
{"task_id": "HumanEval/76", "prompt": "\ndef is_simple_power(x, n):\n    \"\"\"Votre tâche consiste à écrire une fonction qui renvoie vrai si un nombre x est une puissance simple de n et faux dans les autres cas. x est une puissance simple de n si n ** int = x Par exemple : is_simple_power(1, 4) => vrai is_simple_power(2, 2) => vrai is_simple_power(8, 2) => vrai is_simple_power(3, 2) => faux is_simple_power(3, 1) => faux is_simple_power(5, 3) => faux\"\"\"\n", "entry_point": "is_simple_power", "canonical_solution": "    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/133", "prompt": "\n\ndef sum_squares(lst):\n    \"\"\"Vous avez une liste de nombres.\nVous devez retourner la somme des carrés des nombres dans la liste donnée,\narrondissez chaque élément de la liste à l'entier supérieur (plafond) d'abord.\nExemples :\nPour lst = [1,2,3], la sortie doit être 14\nPour lst = [1,4,9], la sortie doit être 98\nPour lst = [1,3,5,7], la sortie doit être 84\nPour lst = [1.4,4.2,0], la sortie doit être 29\nPour lst = [-2.4,1,1], la sortie doit être 6\"\"\"\n", "entry_point": "sum_squares", "canonical_solution": "    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/101", "prompt": "\ndef words_string(s):\n    \"\"\"Vous recevrez une chaîne de mots séparés par des virgules ou des espaces. Votre tâche est de diviser la chaîne en mots et de renvoyer un tableau des mots.\n\nPar exemple:\nwords_string(\"Bonjour, mon nom est John\") == [\"Bonjour\", \"mon\", \"nom\", \"est\", \"John\"]\nwords_string(\"Un, deux, trois, quatre, cinq, six\") == [\"Un\", \"deux\", \"trois\", \"quatre\", \"cinq\", \"six\"]\"\"\"\n", "entry_point": "words_string", "canonical_solution": "    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n"}
{"task_id": "HumanEval/33", "prompt": "\n\ndef sort_third(l: list):\n    \"\"\"Cette fonction prend une liste l et renvoie une liste l' telle que\n    l' est identique à l aux indices qui ne sont pas divisibles par trois, tandis que ses valeurs aux indices qui sont divisibles par trois sont égales\n    aux valeurs des indices correspondants de l, mais triées.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\"\"\"\n", "entry_point": "sort_third", "canonical_solution": "    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n"}
{"task_id": "HumanEval/91", "prompt": "\ndef is_bored(S):\n    \"\"\"Vous recevrez une chaîne de mots, et votre tâche sera de compter le nombre d'ennuis. Un ennui est une phrase qui commence par le mot \"Je\". Les phrases sont délimitées par '.', '?' ou '!'.\n\nPar exemple:\n>>> is_bored(\"Bonjour le monde\")\n0\n>>> is_bored(\"Le ciel est bleu. Le soleil brille. J'adore ce temps\")\n1\"\"\"\n", "entry_point": "is_bored", "canonical_solution": "    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/118", "prompt": "\ndef get_closest_vowel(word):\n    \"\"\"Vous recevez un mot. Votre tâche est de trouver la voyelle la plus proche qui se situe entre deux consonnes du côté droit du mot (sensible à la casse).\n\nLes voyelles au début et à la fin ne sont pas prises en compte. Retournez une chaîne vide si vous ne trouvez pas de voyelle répondant à cette condition.\n\nVous pouvez supposer que la chaîne donnée ne contient que des lettres anglaises.\n\nExemple :\nget_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\"\n", "entry_point": "get_closest_vowel", "canonical_solution": "    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/20", "prompt": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"À partir d'une liste de nombres fournie (d'une longueur d'au moins deux), sélectionnez et retournez deux nombres qui sont les plus proches l'un de l'autre et renvoyez-les dans l'ordre (plus petit nombre, plus grand nombre).\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n(2.0, 2.2)\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n(2.0, 2.0)\"\"\"\n", "entry_point": "find_closest_elements", "canonical_solution": "    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n", "test": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n"}
{"task_id": "HumanEval/90", "prompt": "\ndef next_smallest(lst):\n    \"\"\"Vous avez une liste d'entiers.\nÉcrivez une fonction prochain_plus_petit() qui renvoie le deuxième plus petit élément de la liste.\nRenvoyez None s'il n'y a pas un tel élément.\n\nprochain_plus_petit([1, 2, 3, 4, 5]) == 2\nprochain_plus_petit([5, 1, 4, 3, 2]) == 2\nprochain_plus_petit([]) == None\nprochain_plus_petit([1, 1]) == None\"\"\"\n", "entry_point": "next_smallest", "canonical_solution": "    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/63", "prompt": "\n\ndef fibfib(n: int):\n    \"\"\"La séquence de nombres FibFib est une séquence similaire à la séquence de Fibonacci qui est définie comme suit :\nfibfib(0) == 0\nfibfib(1) == 0\nfibfib(2) == 1\nfibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\nVeuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres fibfib.\n>>> fibfib(1)\n0\n>>> fibfib(5)\n4\n>>> fibfib(8)\n24\"\"\"\n", "entry_point": "fibfib", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n"}
{"task_id": "HumanEval/100", "prompt": "\ndef make_a_pile(n):\n    \"\"\"Étant donné un entier positif n, vous devez créer une pile de n niveaux de pierres.\nLe premier niveau a n pierres.\nLe nombre de pierres dans le niveau suivant est:\n        - le prochain nombre impair si n est impair.\n        - le prochain nombre pair si n est pair.\nRetournez le nombre de pierres dans chaque niveau sous forme de liste, où l'élément à l'indice i représente le nombre de pierres dans le niveau (i+1).\n\nExemples:\n>>> make_a_pile(3)\n[3, 5, 7]\"\"\"\n", "entry_point": "make_a_pile", "canonical_solution": "    return [n + 2*i for i in range(n)]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/88", "prompt": "\ndef sort_array(array):\n    \"\"\"Donné un tableau de nombres entiers non négatifs, renvoie une copie du tableau donné après le tri, vous trierez le tableau donné par ordre croissant si la somme (valeur de l'indice de départ, valeur de l'indice final) est impair, ou le trierez par ordre décroissant si la somme (valeur de l'indice de départ, valeur de l'indice final) est pair.\n\nNote:\n* ne pas modifier le tableau donné.\n\nExemples:\n* sort_array([]) => []\n* sort_array([5]) => [5]\n* sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n* sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\"\"\"\n", "entry_point": "sort_array", "canonical_solution": "    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n"}
{"task_id": "HumanEval/106", "prompt": "\ndef f(n):\n    \"\"\"Implémentez la fonction f qui prend n en tant que paramètre,\n et renvoie une liste de taille n, telle que la valeur de l'élément à l'index i soit le factoriel de i si i est pair, \n sinon la somme des nombres de 1 à i.\n i commence à 1.\n le factoriel de i est la multiplication des nombres de 1 à i (1 * 2 * ... * i).\n Exemple:\n f(5) == [1, 2, 6, 24, 15]\"\"\"\n", "entry_point": "f", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n", "test": "def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n"}
{"task_id": "HumanEval/111", "prompt": "\ndef histogram(test):\n    \"\"\"Étant donné une chaîne de caractères représentant des lettres minuscules séparées par des espaces, renvoyez un dictionnaire contenant la lettre avec le plus de répétitions et contenant le nombre correspondant. Si plusieurs lettres ont la même occurrence, renvoyez-les toutes.\n    \n    Exemple:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\"\"\"\n", "entry_point": "histogram", "canonical_solution": "    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/96", "prompt": "\ndef count_up_to(n):\n    \"\"\"Implémentez une fonction qui prend un entier non négatif et renvoie un tableau des n premiers entiers qui sont des nombres premiers et inférieurs à n.\npar exemple:\ncount_up_to(5) => [2,3]\ncount_up_to(11) => [2,3,5,7]\ncount_up_to(0) => []\ncount_up_to(20) => [2,3,5,7,11,13,17,19]\ncount_up_to(1) => []\ncount_up_to(18) => [2,3,5,7,11,13,17]\"\"\"\n", "entry_point": "count_up_to", "canonical_solution": "    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n", "test": "def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n"}
{"task_id": "HumanEval/139", "prompt": "\ndef special_factorial(n):\n    \"\"\"Le factoriel brésilien est défini comme suit :\n    factoriel_brésilien(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    où n > 0\n\n    Par exemple :\n    >>> factoriel_spécial(4)\n    288\n\n    La fonction recevra un entier en entrée et devra renvoyer le factoriel spécial de cet entier.\"\"\"\n", "entry_point": "special_factorial", "canonical_solution": "    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n"}
{"task_id": "HumanEval/41", "prompt": "\n\ndef car_race_collision(n: int):\n    \"\"\"Imaginez une route qui est une ligne infiniment longue et parfaitement droite.\n    n voitures conduisent de gauche à droite ; simultanément, un ensemble différent de n voitures\n    conduisent de droite à gauche. Les deux ensembles de voitures commencent très loin l'un de l'autre.\n    Toutes les voitures se déplacent à la même vitesse. Deux voitures entrent en collision\n    lorsqu'une voiture qui se déplace de gauche à droite heurte une voiture qui se déplace de droite à gauche.\n    Cependant, les voitures sont infiniment robustes et solides ; par conséquent, elles continuent de se déplacer\n    dans leur trajectoire comme si elles n'avaient pas collisionné.\n\n    Cette fonction renvoie le nombre de telles collisions.\"\"\"\n", "entry_point": "car_race_collision", "canonical_solution": "    return n**2\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n"}
{"task_id": "HumanEval/73", "prompt": "\ndef smallest_change(arr):\n    \"\"\"Étant donné un tableau arr d'entiers, trouvez le nombre minimum d'éléments qui doivent être modifiés pour rendre le tableau palindrome. Un tableau palindrome est un tableau qui se lit de la même manière de gauche à droite et de droite à gauche. Lors d'une modification, vous pouvez changer un élément par n'importe quel autre élément.\n\nPar exemple:\nsmallest_change([1,2,3,5,4,7,9,6]) == 4\nsmallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\nsmallest_change([1, 2, 3, 2, 1]) == 0\"\"\"\n", "entry_point": "smallest_change", "canonical_solution": "    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n"}
{"task_id": "HumanEval/145", "prompt": "\ndef order_by_points(nums):\n    \"\"\"Écrivez une fonction qui trie la liste donnée d'entiers dans l'ordre croissant en fonction de la somme de leurs chiffres. Notez que si plusieurs éléments ont une somme similaire de leurs chiffres, ils doivent être triés en fonction de leur indice dans la liste originale.\n\nPar exemple:\n>>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n>>> order_by_points([]) == []\"\"\"\n", "entry_point": "order_by_points", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/112", "prompt": "\ndef reverse_delete(s,c):\n    \"\"\"Tâche\n    Nous avons deux chaînes de caractères s et c. Vous devez supprimer tous les caractères de s qui sont égaux à n'importe quel caractère de c.\n    Ensuite, vérifiez si la chaîne de caractères résultante est un palindrome.\n    Une chaîne de caractères est appelée palindrome si elle se lit de la même manière de l'avant vers l'arrière.\n    Vous devez retourner un tuple contenant la chaîne de caractères résultante et True/False pour la vérification.\n    Exemple\n    Pour s = \"abcde\", c = \"ae\", le résultat devrait être ('bcd', False)\n    Pour s = \"abcdef\", c = \"b\", le résultat devrait être ('acdef', False)\n    Pour s = \"abcdedcba\", c = \"ab\", le résultat devrait être ('cdedc', True)\"\"\"\n", "entry_point": "reverse_delete", "canonical_solution": "    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n", "test": "def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n"}
{"task_id": "HumanEval/154", "prompt": "\ndef cycpattern_check(a , b):\n    \"\"\"Vous avez deux mots. Vous devez renvoyer True si le deuxième mot ou l'une de ses rotations est une sous-chaîne dans le premier mot.\n    cycpattern_check(\"abcd\", \"abd\") => False\n    cycpattern_check(\"hello\", \"ell\") => True\n    cycpattern_check(\"whassup\", \"psus\") => False\n    cycpattern_check(\"abab\", \"baa\") => True\n    cycpattern_check(\"efef\", \"eeff\") => False\n    cycpattern_check(\"himenss\", \"simen\") => True\"\"\"\n", "entry_point": "cycpattern_check", "canonical_solution": "    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n"}
{"task_id": "HumanEval/67", "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"Dans cette tâche, vous recevrez une chaîne de caractères qui représente un nombre de pommes et d'oranges qui sont réparties dans un panier de fruits. Ce panier contient des pommes, des oranges et des mangues. Étant donné la chaîne qui représente le nombre total d'oranges et de pommes, ainsi qu'un entier qui représente le nombre total de fruits dans le panier, renvoyez le nombre de mangues dans le panier.\npar exemple :\nfruit_distribution(\"5 pommes et 6 oranges\", 19) -> 19 - 5 - 6 = 8\nfruit_distribution(\"0 pommes et 1 orange\", 3) -> 3 - 0 - 1 = 2\nfruit_distribution(\"2 pommes et 3 oranges\", 100) -> 100 - 2 - 3 = 95\nfruit_distribution(\"100 pommes et 1 orange\", 120) -> 120 - 100 - 1 = 19\"\"\"\n", "entry_point": "fruit_distribution", "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n"}
{"task_id": "HumanEval/137", "prompt": "\ndef compare_one(a, b):\n    \"\"\"Créez une fonction qui prend des entiers, des nombres à virgule flottante ou des chaînes de caractères représentant des nombres réels et renvoie la variable la plus grande de son type de variable donné. Renvoyez None si les valeurs sont égales. Notez : Si un nombre réel est représenté par une chaîne de caractères, le point décimal peut être . ou , \n\ncompare_one(1, 2.5) ➞ 2.5\ncompare_one(1, \"2,3\") ➞ \"2,3\"\ncompare_one(\"5,1\", \"6\") ➞ \"6\"\ncompare_one(\"1\", 1) ➞ None\"\"\"\n", "entry_point": "compare_one", "canonical_solution": "    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/103", "prompt": "\ndef rounded_avg(n, m):\n    \"\"\"Vous disposez de deux nombres entiers positifs, n et m, et votre tâche consiste à calculer la moyenne des entiers de n à m (y compris n et m). Arrondissez la réponse à l'entier le plus proche et convertissez-la en binaire. Si n est supérieur à m, renvoyez -1.\nExemple :\nrounded_avg(1, 5) => \"0b11\"\nrounded_avg(7, 5) => -1\nrounded_avg(10, 20) => \"0b1111\"\nrounded_avg(20, 33) => \"0b11010\"\"\"\n", "entry_point": "rounded_avg", "canonical_solution": "    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n"}
{"task_id": "HumanEval/128", "prompt": "\ndef prod_signs(arr):\n    \"\"\"Vous disposez d'un tableau 'arr' d'entiers et vous devez retourner la somme des magnitudes des entiers multipliée par le produit de tous les signes de chaque nombre dans le tableau, représenté par 1, -1 ou 0.\nRemarque: retournez None si 'arr' est vide.\n\nExemple:\n>>> prod_signs([1, 2, 2, -4]) == -9\n>>> prod_signs([0, 1]) == 0\n>>> prod_signs([]) == None\"\"\"\n", "entry_point": "prod_signs", "canonical_solution": "    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/120", "prompt": "\ndef maximum(arr, k):\n    \"\"\"Donné un tableau arr d'entiers et un entier positif k, renvoyer une liste triée de longueur k avec les k nombres maximum de arr.\n\nExemple 1:\n\n    Entrée: arr = [-3, -4, 5], k = 3\n    Sortie: [-4, -3, 5]\n\nExemple 2:\n\n    Entrée: arr = [4, -4, 4], k = 2\n    Sortie: [4, 4]\n\nExemple 3:\n\n    Entrée: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n    Sortie: [2]\n\nNote:\n    1. La longueur du tableau sera dans la plage [1, 1000].\n    2. Les éléments du tableau seront dans la plage [-1000, 1000].\n    3. 0 <= k <= len(arr)\"\"\"\n", "entry_point": "maximum", "canonical_solution": "    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n"}
{"task_id": "HumanEval/107", "prompt": "\ndef even_odd_palindrome(n):\n    \"\"\"Étant donné un entier positif n, renvoyez un tuple qui contient le nombre de nombres palindromes pairs et impairs qui se trouvent dans la plage (1, n), inclusivement.\n\nExemple 1:\n\n    Entrée: 3\n    Sortie: (1, 2)\n    Explication:\n    Les nombres palindromes sont 1, 2, 3. Un d'entre eux est pair et deux d'entre eux sont impairs.\n\nExemple 2:\n\n    Entrée: 12\n    Sortie: (4, 6)\n    Explication:\n    Les nombres palindromes sont 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Quatre d'entre eux sont pairs et six d'entre eux sont impairs.\n\nNote:\n    1. 1 <= n <= 10^3\n    2. Le tuple renvoyé contient respectivement le nombre de nombres palindromes pairs et impairs.\"\"\"\n", "entry_point": "even_odd_palindrome", "canonical_solution": "    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/110", "prompt": "\ndef exchange(lst1, lst2):\n    \"\"\"Dans ce problème, vous allez implémenter une fonction qui prend deux listes de nombres et détermine s'il est possible d'échanger des éléments entre elles pour faire de lst1 une liste de nombres pairs uniquement. Il n'y a pas de limite sur le nombre d'éléments échangés entre lst1 et lst2. S'il est possible d'échanger des éléments entre lst1 et lst2 pour que tous les éléments de lst1 soient pairs, retournez \"YES\". Sinon, retournez \"NO\". Par exemple: exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\" exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\" On suppose que les listes d'entrée ne seront pas vides.\"\"\"\n", "entry_point": "exchange", "canonical_solution": "    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n"}
{"task_id": "HumanEval/113", "prompt": "\ndef odd_count(lst):\n    \"\"\"Donné une liste de chaînes de caractères, où chaque chaîne consiste uniquement de chiffres, retourne une liste.\n    Chaque élément i de la sortie doit être \"le nombre d'éléments impairs dans la\n    chaîne i de l'entrée.\" où tous les i doivent être remplacés par le nombre\n    de chiffres impairs dans la i-ème chaîne de l'entrée.\n\n    >>> odd_count(['1234567'])\n    [\"le nombre d'éléments impairs dans la chaîne 4 de l'entrée.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"le nombre d'éléments impairs dans la chaîne 1 de l'entrée.\",\n     \"le nombre d'éléments impairs dans la chaîne 8 de l'entrée.\"]\"\"\"\n", "entry_point": "odd_count", "canonical_solution": "    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/124", "prompt": "\ndef valid_date(date):\n    \"\"\"Vous devez écrire une fonction qui valide une chaîne de date donnée et renvoie True si la date est valide, sinon False. La date est valide si toutes les règles suivantes sont satisfaites: 1. La chaîne de date n'est pas vide. 2. Le nombre de jours n'est pas inférieur à 1 ou supérieur à 31 jours pour les mois 1, 3, 5, 7, 8, 10, 12. Et le nombre de jours n'est pas inférieur à 1 ou supérieur à 30 jours pour les mois 4, 6, 9, 11. Et le nombre de jours n'est pas inférieur à 1 ou supérieur à 29 pour le mois 2. 3. Les mois ne doivent pas être inférieurs à 1 ou supérieurs à 12. 4. La date doit être au format: mm-jj-aaaa Par exemple: valid_date ('03-11-2000') => True valid_date ('15-01-2012') => False valid_date ('04-0-2040') => False valid_date ('06-04-2020') => True valid_date ('06/04/2020') => False\"\"\"\n", "entry_point": "valid_date", "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n"}
{"task_id": "HumanEval/40", "prompt": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"triples_sum_to_zero prend une liste d'entiers en entrée.\nIl renvoie True s'il y a trois éléments distincts dans la liste qui\ns'additionnent à zéro, et False sinon.\n\n>>> triples_sum_to_zero([1, 3, 5, 0])\nFalse\n>>> triples_sum_to_zero([1, 3, -2, 1])\nTrue\n>>> triples_sum_to_zero([1, 2, 3, 7])\nFalse\n>>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\nTrue\n>>> triples_sum_to_zero([1])\nFalse\"\"\"\n", "entry_point": "triples_sum_to_zero", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n"}
{"task_id": "HumanEval/46", "prompt": "\n\ndef fib4(n: int):\n    \"\"\"La séquence des nombres Fib4 est une séquence similaire à la séquence de Fibonacci qui est définie comme suit :\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Veuillez écrire une fonction pour calculer efficacement le n-ième élément de la séquence de nombres Fib4. N'utilisez pas la récursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\"\"\"\n", "entry_point": "fib4", "canonical_solution": "    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n", "test": "\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n"}
{"task_id": "HumanEval/105", "prompt": "\ndef by_length(arr):\n    \"\"\"Étant donné un tableau d'entiers, triez les entiers qui sont compris entre 1 et 9 inclus, inversez le tableau résultant, puis remplacez chaque chiffre par son nom correspondant de \"Un\", \"Deux\", \"Trois\", \"Quatre\", \"Cinq\", \"Six\", \"Sept\", \"Huit\", \"Neuf\".\n\nPar exemple:\narr = [2, 1, 1, 4, 5, 8, 2, 3]\n-> trier arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n-> inverser arr -> [8, 5, 4, 3, 2, 2, 1, 1]\nretourner [\"Huit\", \"Cinq\", \"Quatre\", \"Trois\", \"Deux\", \"Deux\", \"Un\", \"Un\"]\n\nSi le tableau est vide, retournez un tableau vide:\narr = []\nretournez []\n\nSi le tableau contient un nombre étrange, ignorez-le:\narr = [1, -1, 55]\n-> trier arr -> [-1, 1, 55]\n-> inverser arr -> [55, 1, -1]\nretour = ['Un']\"\"\"\n", "entry_point": "by_length", "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n"}
{"task_id": "HumanEval/87", "prompt": "\ndef get_row(lst, x):\n    \"\"\"Vous avez une donnée bidimensionnelle, sous forme de listes imbriquées, qui ressemble à une matrice, cependant, contrairement aux matrices, chaque ligne peut contenir un nombre différent de colonnes. Étant donné lst et un entier x, trouvez les entiers x dans la liste, et renvoyez une liste de tuples, [(x1, y1), (x2, y2) ...] tels que chaque tuple soit une coordonnée - (ligne, colonne), en commençant par 0. Triez les coordonnées initialement par lignes dans l'ordre croissant. De plus, triez les coordonnées de la ligne par colonnes dans l'ordre décroissant.\n\nExemples:\nget_row([\n  [1,2,3,4,5,6],\n  [1,2,3,4,1,6],\n  [1,2,3,4,5,1]\n], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nget_row([], 1) == []\nget_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\"\"\"\n", "entry_point": "get_row", "canonical_solution": "    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/86", "prompt": "\ndef anti_shuffle(s):\n    \"\"\"Écrivez une fonction qui prend une chaîne de caractères et renvoie une version ordonnée de celle-ci.\nLa version ordonnée de la chaîne est une chaîne où tous les mots (séparés par un espace)\nsont remplacés par un nouveau mot où tous les caractères sont arrangés en ordre croissant basé sur la valeur ascii.\nNote : Vous devez conserver l'ordre des mots et les espaces vides dans la phrase.\n\nPar exemple :\nanti_shuffle('Hi') renvoie 'Hi'\nanti_shuffle('hello') renvoie 'ehllo'\nanti_shuffle('Hello World!!!') renvoie 'Hello !!!Wdlor'\"\"\"\n", "entry_point": "anti_shuffle", "canonical_solution": "    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/116", "prompt": "\ndef sort_array(arr):\n    \"\"\"Dans cette Kata, vous devez trier un tableau d'entiers non négatifs selon le nombre de 1 dans leur représentation binaire, par ordre croissant. Pour un nombre similaire de 1, triez selon la valeur décimale.\n\nIl doit être implémenté comme ceci :\n>>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n>>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n>>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\"\"\"\n", "entry_point": "sort_array", "canonical_solution": "    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/130", "prompt": "\ndef tri(n):\n    \"\"\"Tout le monde connaît la séquence de Fibonacci, elle a été étudiée en profondeur par les mathématiciens au cours des derniers siècles. Cependant, ce que les gens ne savent pas, c'est la séquence de Tribonacci. La séquence de Tribonacci est définie par la récurrence suivante : \ntri(1) = 3\ntri(n) = 1 + n / 2, si n est pair.\ntri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), si n est impair.\nPar exemple :\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n       = 2 + 3 + 3 = 8\nVous avez un nombre entier non négatif n, vous devez retourner une liste des n + 1 premiers nombres de la séquence de Tribonacci.\nExemples :\ntri(3) = [1, 3, 2, 8]\"\"\"\n", "entry_point": "tri", "canonical_solution": "    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n"}
{"task_id": "HumanEval/80", "prompt": "\ndef is_happy(s):\n    \"\"\"Vous avez une chaîne de caractères s.\nVotre tâche est de vérifier si la chaîne est heureuse ou non.\nUne chaîne est heureuse si sa longueur est d'au moins 3 et que chaque groupe de 3 lettres consécutives est distinct.\nPar exemple:\nis_happy(a) => Faux\nis_happy(aa) => Faux\nis_happy(abcd) => Vrai\nis_happy(aabb) => Faux\nis_happy(adb) => Vrai\nis_happy(xyy) => Faux\"\"\"\n", "entry_point": "is_happy", "canonical_solution": "    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n"}
{"task_id": "HumanEval/144", "prompt": "\ndef simplify(x, n):\n    \"\"\"Votre tâche consiste à implémenter une fonction qui simplifiera l'expression x * n. La fonction renvoie True si x * n évalue à un nombre entier et False sinon. Les variables x et n sont des représentations sous forme de chaîne d'une fraction et ont le format suivant : <numérateur>/<dénominateur>, où le numérateur et le dénominateur sont des nombres entiers positifs.\n\nVous pouvez supposer que x et n sont des fractions valides et n'ont pas zéro comme dénominateur.\n\nsimplify(\"1/5\", \"5/1\") = True\nsimplify(\"1/6\", \"2/1\") = False\nsimplify(\"7/10\", \"10/2\") = False\"\"\"\n", "entry_point": "simplify", "canonical_solution": "    a, b = x.split(\"/\")\n    c, d = n.split(\"/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator/denom == int(numerator/denom)):\n        return True\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1/5\", \"5/1\") == True, 'test1'\n    assert candidate(\"1/6\", \"2/1\") == False, 'test2'\n    assert candidate(\"5/1\", \"3/1\") == True, 'test3'\n    assert candidate(\"7/10\", \"10/2\") == False, 'test4'\n    assert candidate(\"2/10\", \"50/10\") == True, 'test5'\n    assert candidate(\"7/2\", \"4/2\") == True, 'test6'\n    assert candidate(\"11/6\", \"6/1\") == True, 'test7'\n    assert candidate(\"2/3\", \"5/2\") == False, 'test8'\n    assert candidate(\"5/2\", \"3/5\") == False, 'test9'\n    assert candidate(\"2/4\", \"8/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2/4\", \"4/2\") == True, 'test11'\n    assert candidate(\"1/5\", \"5/1\") == True, 'test12'\n    assert candidate(\"1/5\", \"1/5\") == False, 'test13'\n\n"}
{"task_id": "HumanEval/156", "prompt": "\ndef int_to_mini_roman(number):\n    \"\"\"Étant donné un entier positif, obtenez son équivalent en chiffres romains sous forme de chaîne de caractères et renvoyez-le en minuscules.\nRestrictions : 1 <= num <= 1000\n\nExemples :\n>>> int_to_mini_roman(19) == 'xix'\n>>> int_to_mini_roman(152) == 'clii'\n>>> int_to_mini_roman(426) == 'cdxxvi'\"\"\"\n", "entry_point": "int_to_mini_roman", "canonical_solution": "    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number // num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/152", "prompt": "\ndef compare(game,guess):\n    \"\"\"Je pense que nous nous souvenons tous de ce sentiment lorsque le résultat d'un événement tant attendu est enfin connu. Les sentiments et les pensées que vous avez à ce moment-là valent certainement la peine d'être notés et comparés. Votre tâche consiste à déterminer si une personne a correctement deviné les résultats d'un certain nombre de matchs. Vous avez deux tableaux de scores et de prédictions de même longueur, où chaque index représente un match. Renvoyez un tableau de la même longueur indiquant dans quelle mesure chaque prédiction était incorrecte. Si elle a correctement deviné, la valeur est 0, sinon la valeur est la différence absolue entre la prédiction et le score.\n\nexemple:\n\ncomparer([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\ncomparer([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\"\"\"\n", "entry_point": "compare", "canonical_solution": "    return [abs(x-y) for x,y in zip(game,guess)]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/123", "prompt": "\ndef get_odd_collatz(n):\n    \"\"\"Étant donné un entier positif n, renvoyez une liste triée qui contient les nombres impairs dans la séquence de Collatz.\n\nLa conjecture de Collatz est une conjecture en mathématiques qui concerne une séquence définie comme suit : commencez par un entier positif n. Ensuite, chaque terme est obtenu à partir du terme précédent selon les règles suivantes : si le terme précédent est pair, le terme suivant est la moitié du terme précédent. Si le terme précédent est impair, le terme suivant est trois fois le terme précédent plus un. La conjecture affirme que quelle que soit la valeur de n, la séquence atteindra toujours 1.\n\nNote :\n  1. Collatz(1) est [1].\n  2. La liste renvoyée est triée dans l'ordre croissant.\n\nPar exemple :\nget_odd_collatz(5) renvoie [1, 5] # La séquence de Collatz pour 5 est [5, 16, 8, 4, 2, 1], donc les nombres impairs sont seulement 1 et 5.\"\"\"\n", "entry_point": "get_odd_collatz", "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/95", "prompt": "\ndef check_dict_case(dict):\n    \"\"\"Donné un dictionnaire, renvoyer True si toutes les clés sont des chaînes de caractères en minuscules ou si toutes les clés sont des chaînes de caractères en majuscules, sinon renvoyer False. La fonction devrait renvoyer False si le dictionnaire donné est vide. Exemples : check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) devrait renvoyer True. check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) devrait renvoyer False. check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) devrait renvoyer False. check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) devrait renvoyer False. check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) devrait renvoyer True.\"\"\"\n", "entry_point": "check_dict_case", "canonical_solution": "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n"}
{"task_id": "HumanEval/127", "prompt": "\ndef intersection(interval1, interval2):\n    \"\"\"Vous recevez deux intervalles, où chaque intervalle est une paire d'entiers. Par exemple, intervalle = (début, fin) = (1, 2). Les intervalles donnés sont fermés, ce qui signifie que l'intervalle (début, fin) inclut à la fois le début et la fin. Pour chaque intervalle donné, on suppose que son début est inférieur ou égal à sa fin. Votre tâche consiste à déterminer si la longueur de l'intersection de ces deux intervalles est un nombre premier. Par exemple, l'intersection des intervalles (1, 3) et (2, 4) est (2, 3) dont la longueur est 1, qui n'est pas un nombre premier. Si la longueur de l'intersection est un nombre premier, retournez \"YES\", sinon, retournez \"NO\". Si les deux intervalles ne se chevauchent pas, retournez \"NO\".\n\n[input/output] exemples :\nintersection((1, 2), (2, 3)) ==> \"NO\"\nintersection((-1, 1), (0, 4)) ==> \"NO\"\nintersection((-3, -1), (-5, 5)) ==> \"YES\"\"\"\n", "entry_point": "intersection", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n"}
{"task_id": "HumanEval/140", "prompt": "\ndef fix_spaces(text):\n    \"\"\"Étant donné une chaîne de caractères text, remplacez tous les espaces par des tirets bas et si une chaîne a plus de 2 espaces consécutifs, remplacez tous les espaces consécutifs par un tiret.\n\nfix_spaces(\"Exemple\") == \"Exemple\"\nfix_spaces(\"Exemple 1\") == \"Exemple_1\"\nfix_spaces(\" Exemple 2\") == \"_Exemple_2\"\nfix_spaces(\" Exemple   3\") == \"_Exemple-3\"\"\"\n", "entry_point": "fix_spaces", "canonical_solution": "    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n"}
{"task_id": "HumanEval/94", "prompt": "\n\ndef skjkasdkd(lst):\n    \"\"\"Vous avez une liste d'entiers.\nVous devez trouver la plus grande valeur première et retourner la somme de ses chiffres.\n\nExemples :\nPour lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3], la sortie devrait être 10\nPour lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1], la sortie devrait être 25\nPour lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3], la sortie devrait être 13\nPour lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6], la sortie devrait être 11\nPour lst = [0,81,12,3,1,21], la sortie devrait être 3\nPour lst = [0,8,1,2,1,7], la sortie devrait être 7\"\"\"\n", "entry_point": "skjkasdkd", "canonical_solution": "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n"}
{"task_id": "HumanEval/161", "prompt": "\ndef solve(s):\n    \"\"\"Vous avez une chaîne de caractères s.\nsi s[i] est une lettre, inversez sa casse de minuscule en majuscule ou vice versa,\nsinon gardez-le tel quel.\nSi la chaîne ne contient pas de lettres, inversez la chaîne.\nLa fonction devrait renvoyer la chaîne résultante.\nExemples\nsolve(\"1234\") = \"4321\"\nsolve(\"ab\") = \"AB\"\nsolve(\"#a@C\") = \"#A@c\"\"\"\n", "entry_point": "solve", "canonical_solution": "    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n"}
{"task_id": "HumanEval/141", "prompt": "\ndef file_name_check(file_name):\n    \"\"\"Créez une fonction qui prend en paramètre une chaîne de caractères représentant le nom d'un fichier, et renvoie 'Oui' si le nom du fichier est valide, et renvoie 'Non' sinon. Le nom d'un fichier est considéré comme valide si et seulement si toutes les conditions suivantes sont remplies : - Il ne doit pas y avoir plus de trois chiffres ('0'-'9') dans le nom du fichier. - Le nom du fichier contient exactement un point '.' - La sous-chaîne avant le point ne doit pas être vide, et elle commence par une lettre de l'alphabet latin ('a'-'z' et 'A'-'Z'). - La sous-chaîne après le point doit être l'une des suivantes : ['txt', 'exe', 'dll'] Exemples : file_name_check(\"example.txt\") # => 'Oui' file_name_check(\"1example.dll\") # => 'Non' (le nom doit commencer par une lettre de l'alphabet latin)\"\"\"\n", "entry_point": "file_name_check", "canonical_solution": "    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n"}
{"task_id": "HumanEval/109", "prompt": "\ndef move_one_ball(arr):\n    \"\"\"Nous avons un tableau 'arr' de N entiers arr[1], arr[2], ..., arr[N]. Les nombres dans le tableau seront mélangés aléatoirement. Votre tâche consiste à déterminer s'il est possible d'obtenir un tableau trié dans l'ordre croissant en effectuant l'opération suivante sur le tableau donné:\n\n    Vous êtes autorisé à effectuer une opération de décalage vers la droite un nombre quelconque de fois.\n    \n    Une opération de décalage vers la droite signifie décaler tous les éléments du tableau d'une position vers la droite. Le dernier élément du tableau sera déplacé à la position de départ du tableau, c'est-à-dire à l'indice 0. \n\n    Si l'on peut obtenir le tableau trié en effectuant l'opération ci-dessus, renvoie True. Sinon, renvoie False.\n    Si le tableau donné est vide, renvoie True.\n\n    Remarque : La liste donnée est garantie d'avoir des éléments uniques.\n\n    Par exemple:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explication: En effectuant 2 opérations de décalage vers la droite, on peut obtenir un ordre croissant pour le tableau donné.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explication: Il n'est pas possible d'obtenir un ordre croissant pour le tableau donné en effectuant un nombre quelconque d'opérations de décalage vers la droite.\"\"\"\n", "entry_point": "move_one_ball", "canonical_solution": "    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n"}
{"task_id": "HumanEval/160", "prompt": "\ndef do_algebra(operator, operand):\n    \"\"\"Étant donné deux listes \"operator\" et \"operand\". La première liste contient les opérations fondamentales de l'algèbre, et la deuxième liste est une liste d'entiers. Utilisez les deux listes données pour construire l'expression algébrique et renvoyer l'évaluation de cette expression.\n\nLes opérations fondamentales de l'algèbre sont :\nAddition ( + )\nSoustraction ( - )\nMultiplication ( * )\nDivision entière ( // )\nExponentiation ( ** )\n\nExemple :\noperator['+', '*', '-']\narray = [2, 3, 4, 5]\nresult = 2 + 3 * 4 - 5\n=> result = 9\n\nNote :\nLa longueur de la liste \"operator\" est égale à la longueur de la liste \"operand\" moins un.\n\"Operand\" est une liste d'entiers non négatifs.\nLa liste \"operator\" contient au moins un opérateur, et la liste \"operand\" contient au moins deux opérandes.\"\"\"\n", "entry_point": "do_algebra", "canonical_solution": "    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/158", "prompt": "\ndef find_max(words):\n    \"\"\"Écrivez une fonction qui accepte une liste de chaînes de caractères.\nLa liste contient différents mots. Renvoyez le mot avec le plus grand nombre de caractères uniques. Si plusieurs chaînes ont le même nombre maximum de caractères uniques, renvoyez celle qui vient en premier dans l'ordre lexicographique.\n\nfind_max([\"name\", \"of\", \"string\"]) == \"string\"\nfind_max([\"name\", \"enam\", \"game\"]) == \"enam\"\nfind_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\"\"\n", "entry_point": "find_max", "canonical_solution": "    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n"}
{"task_id": "HumanEval/81", "prompt": "\ndef numerical_letter_grade(grades):\n    \"\"\"C'est la dernière semaine du semestre et l'enseignant doit donner les notes aux étudiants. L'enseignant a créé son propre algorithme pour la notation. Le seul problème est qu'il a perdu le code qu'il utilisait pour noter. Il vous a donné une liste de GPA pour certains étudiants et vous devez écrire une fonction qui peut produire une liste des notes en utilisant le tableau suivant :\n             GPA       |    Note\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Exemple :\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\"\"\"\n", "entry_point": "numerical_letter_grade", "canonical_solution": "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/159", "prompt": "\ndef eat(number, need, remaining):\n    \"\"\"Tu es un lapin affamé et tu as déjà mangé un certain nombre de carottes,\n    mais maintenant tu as besoin de manger plus de carottes pour compléter les repas de la journée.\n    tu devrais renvoyer un tableau [nombre total de carottes mangées après tes repas,\n                                    le nombre de carottes restantes après tes repas]\n    s'il n'y a pas assez de carottes restantes, tu mangeras toutes les carottes restantes, mais tu auras toujours faim.\n    \n    Exemple:\n    * manger(5, 6, 10) -> [11, 4]\n    * manger(4, 8, 9) -> [12, 1]\n    * manger(1, 10, 10) -> [11, 0]\n    * manger(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @nombre : entier\n        le nombre de carottes que tu as mangées.\n    @besoin : entier\n        le nombre de carottes que tu dois manger.\n    @restant : entier\n        le nombre de carottes restantes qui existent en stock\n    \n    Contraintes:\n    * 0 <= nombre <= 1000\n    * 0 <= besoin <= 1000\n    * 0 <= restant <= 1000\n\n    Amuse-toi bien :)\"\"\"\n", "entry_point": "eat", "canonical_solution": "    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n"}
{"task_id": "HumanEval/162", "prompt": "\ndef string_to_md5(text):\n    \"\"\"Donnée une chaîne de caractères 'texte', retournez une chaîne de caractères équivalente de son md5 hash. \nSi 'texte' est une chaîne de caractères vide, retournez None.\n\n>>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\"\"\"\n", "entry_point": "string_to_md5", "canonical_solution": "    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/155", "prompt": "\ndef even_odd_count(num):\n    \"\"\"Given an integer, return a tuple that contains the number of even and odd digits respectively.\n\n    Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n", "entry_point": "even_odd_count", "canonical_solution": "    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/78", "prompt": "\ndef hex_key(num):\n    \"\"\"Vous avez été chargé d'écrire une fonction qui reçoit un nombre hexadécimal sous forme de chaîne de caractères et qui compte le nombre de chiffres hexadécimaux qui sont des nombres premiers (un nombre premier, ou un nombre premier, est un nombre naturel supérieur à 1 qui n'est pas le produit de deux nombres naturels plus petits). \nLes chiffres hexadécimaux sont 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. \nLes nombres premiers sont 2, 3, 5, 7, 11, 13, 17,...\nVous devez donc déterminer le nombre des chiffres suivants : 2, 3, 5, 7, B (=décimal 11), D (=décimal 13).\nNote : vous pouvez supposer que l'entrée est toujours correcte ou une chaîne vide, et que les symboles A, B, C, D, E, F sont toujours en majuscules.\nExemples :\nPour num = \"AB\", la sortie devrait être 1.\nPour num = \"1077E\", la sortie devrait être 2.\nPour num = \"ABED1A33\", la sortie devrait être 4.\nPour num = \"123456789ABCDEF0\", la sortie devrait être 6.\nPour num = \"2020\", la sortie devrait être 2.\"\"\"\n", "entry_point": "hex_key", "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n"}
{"task_id": "HumanEval/115", "prompt": "\ndef max_fill(grid, capacity):\n    import math\n    \"\"\"Vous disposez d'une grille rectangulaire de puits. Chaque ligne représente un puits unique, et chaque 1 dans une ligne représente une unité d'eau unique.\nChaque puits a un seau correspondant qui peut être utilisé pour extraire l'eau de celui-ci, et tous les seaux ont la même capacité.\nVotre tâche est d'utiliser les seaux pour vider les puits.\nAffichez le nombre de fois que vous devez abaisser les seaux.\n\nExemple 1:\n    Entrée:\n        grille : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n        capacité_du_seau : 1\n    Sortie: 6\n\nExemple 2:\n    Entrée:\n        grille : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n        capacité_du_seau : 2\n    Sortie: 5\n\nExemple 3:\n    Entrée:\n        grille : [[0,0,0], [0,0,0]]\n        capacité_du_seau : 5\n    Sortie: 0\n\nContraintes:\n    * tous les puits ont la même longueur\n    * 1 <= longueur_de_la_grille <= 10^2\n    * 1 <= longueur_de_la_grille[:,1] <= 10^2\n    * grille[i][j] -> 0 | 1\n    * 1 <= capacité <= 10\"\"\"\n", "entry_point": "max_fill", "canonical_solution": "    return sum([math.ceil(sum(arr)/capacity) for arr in grid])\n", "test": "def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n"}
{"task_id": "HumanEval/68", "prompt": "\ndef pluck(arr):\n    \"\"\"Étant donné un tableau représentant une branche d'un arbre qui a des nœuds entiers non négatifs, votre tâche est de cueillir l'un des nœuds et de le retourner. Le nœud cueilli doit être celui ayant la plus petite valeur paire. Si plusieurs nœuds ayant la même plus petite valeur paire sont trouvés, retournez le nœud qui a le plus petit indice.\n\nLe nœud cueilli doit être retourné dans une liste, [valeur_la_plus_petite, son_index], Si aucune valeur paire n'est présente ou si le tableau donné est vide, retournez [].\n\nExemple 1:\n    Entrée: [4,2,3]\n    Sortie: [2, 1]\n    Explication: 2 a la plus petite valeur paire, et 2 a le plus petit indice.\n\nExemple 2:\n    Entrée: [1,2,3]\n    Sortie: [2, 1]\n    Explication: 2 a la plus petite valeur paire, et 2 a le plus petit indice.\n    \nExemple 3:\n    Entrée: []\n    Sortie: []\n    \nExemple 4:\n    Entrée: [5, 0, 3, 0, 4, 2]\n    Sortie: [0, 1]\n    Explication: 0 est la plus petite valeur, mais il y a deux zéros, donc nous choisirons le premier zéro, qui a le plus petit indice.\n\nContraintes:\n    * 1 <= nodes.length <= 10000\n    * 0 <= node.value\"\"\"\n", "entry_point": "pluck", "canonical_solution": "    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n"}
{"task_id": "HumanEval/117", "prompt": "\ndef select_words(s, n):\n    \"\"\"Donné une chaîne de caractères s et un nombre naturel n, vous avez été chargé de mettre en œuvre une fonction qui renvoie une liste de tous les mots de la chaîne s contenant exactement n consonnes, dans l'ordre où ces mots apparaissent dans la chaîne s. Si la chaîne s est vide, la fonction doit renvoyer une liste vide. Note : vous pouvez supposer que la chaîne d'entrée contient uniquement des lettres et des espaces. Exemples : select_words(\"Mary had a little lamb\", 4) ==> [\"little\"] select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"] select_words(\"espaces simples\", 2) ==> [] select_words(\"Bonjour le monde\", 4) ==> [\"monde\"] select_words(\"Oncle Sam\", 3) ==> [\"Oncle\"]\"\"\"\n", "entry_point": "select_words", "canonical_solution": "    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n"}
{"task_id": "HumanEval/149", "prompt": "\ndef sorted_list_sum(lst):\n    \"\"\"Écrivez une fonction qui accepte une liste de chaînes de caractères en tant que paramètre, supprime les chaînes de caractères de longueur impaire de celle-ci, et renvoie la liste résultante dans un ordre trié. La liste est toujours une liste de chaînes de caractères et jamais un tableau de nombres, et elle peut contenir des doublons. L'ordre de la liste doit être croissant en fonction de la longueur de chaque mot, et vous devez renvoyer la liste triée selon cette règle. Si deux mots ont la même longueur, triez la liste par ordre alphabétique. La fonction doit renvoyer une liste de chaînes de caractères dans un ordre trié. Vous pouvez supposer que tous les mots auront la même longueur. Par exemple: assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"] assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\"\"\"\n", "entry_point": "sorted_list_sum", "canonical_solution": "    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n"}
{"task_id": "HumanEval/129", "prompt": "\ndef minPath(grid, k):\n    \"\"\"Étant donné une grille avec N lignes et N colonnes (N >= 2) et un entier positif k, chaque cellule de la grille contient une valeur. Chaque entier dans la plage [1, N * N] inclus apparaît exactement une fois sur les cellules de la grille.\n\nVous devez trouver le chemin minimum de longueur k dans la grille. Vous pouvez commencer à partir de n'importe quelle cellule, et à chaque étape, vous pouvez vous déplacer vers l'une des cellules voisines, en d'autres termes, vous pouvez vous rendre dans des cellules qui partagent un côté avec votre cellule actuelle.\nVeuillez noter qu'un chemin de longueur k signifie visiter exactement k cellules (pas nécessairement distinctes).\nVous NE POUVEZ PAS sortir de la grille.\nUn chemin A (de longueur k) est considéré comme inférieur à un chemin B (de longueur k) si, après avoir construit les listes ordonnées des valeurs des cellules que A et B traversent (appelons-les lst_A et lst_B), lst_A est lexicographiquement inférieur à lst_B, en d'autres termes, il existe un indice entier i (1 <= i <= k) tel que lst_A[i] < lst_B[i] et pour tout j (1 <= j < i) nous avons lst_A[j] = lst_B[j].\nIl est garanti que la réponse est unique.\nRetournez une liste ordonnée des valeurs des cellules que le chemin minimum emprunte.\n\nExemples :\n\n    Entrée : grille = [[1,2,3], [4,5,6], [7,8,9]], k = 3\n    Sortie : [1, 2, 1]\n\n    Entrée : grille = [[5,9,3], [4,1,6], [7,8,2]], k = 1\n    Sortie : [1]\"\"\"\n", "entry_point": "minPath", "canonical_solution": "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n"}
{"task_id": "HumanEval/163", "prompt": "\ndef generate_integers(a, b):\n    \"\"\"Étant donné deux entiers positifs a et b, renvoyez les chiffres pairs entre a et b, dans l'ordre croissant.\n\nPar exemple:\ngenerate_integers(2, 8) => [2, 4, 6, 8]\ngenerate_integers(8, 2) => [2, 4, 6, 8]\ngenerate_integers(10, 14) => []\"\"\"\n", "entry_point": "generate_integers", "canonical_solution": "    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/143", "prompt": "\ndef words_in_sentence(sentence):\n    \"\"\"Vous avez une chaîne de caractères représentant une phrase,\nla phrase contient des mots séparés par un espace,\net vous devez renvoyer une chaîne de caractères qui contient les mots de la phrase d'origine,\ndont les longueurs sont des nombres premiers,\nl'ordre des mots dans la nouvelle chaîne doit être le même que dans l'original.\n\nExemple 1:\n    Entrée: sentence = \"This is a test\"\n    Sortie: \"is\"\n\nExemple 2:\n    Entrée: sentence = \"lets go for swimming\"\n    Sortie: \"go for\"\n\nContraintes:\n    * 1 <= len(sentence) <= 100\n    * sentence contient uniquement des lettres\"\"\"\n", "entry_point": "words_in_sentence", "canonical_solution": "    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n"}
{"task_id": "HumanEval/153", "prompt": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"Vous recevrez le nom d'une classe (une chaîne de caractères) et une liste d'extensions.\nLes extensions doivent être utilisées pour charger des classes supplémentaires dans la classe. La force de l'extension est déterminée comme suit : soit CAP le nombre de lettres majuscules dans le nom de l'extension, et soit SM le nombre de lettres minuscules dans le nom de l'extension, la force est donnée par la fraction CAP - SM. Vous devez trouver l'extension la plus forte et renvoyer une chaîne de caractères dans ce format : NomDeLaClasse.NomDeLExtensionLaPlusForte.\nS'il y a deux extensions ou plus ayant la même force, vous devez choisir celle qui apparaît en premier dans la liste.\nPar exemple, si vous avez \"Slices\" comme classe et une liste d'extensions : ['SErviNGSliCes', 'Cheese', 'StuFfed'], vous devez renvoyer 'Slices.SErviNGSliCes' car 'SErviNGSliCes' est l'extension la plus forte (sa force est -1).\nExemple :\npour Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\"\"\"\n", "entry_point": "Strongest_Extension", "canonical_solution": "    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n"}
{"task_id": "HumanEval/157", "prompt": "\ndef right_angle_triangle(a, b, c):\n    '''\n    Étant donné les longueurs des trois côtés d'un triangle. Renvoyer True si les trois côtés forment un triangle rectangle, False sinon.\nUn triangle rectangle est un triangle dans lequel un angle est un angle droit ou 90 degrés.\nExemple :\nright_angle_triangle(3, 4, 5) == True\nright_angle_triangle(1, 2, 3) == False\n'''\n", "entry_point": "right_angle_triangle", "canonical_solution": "    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n"}
{"task_id": "HumanEval/70", "prompt": "\ndef strange_sort_list(lst):\n    '''\n    Étant donné une liste d'entiers, renvoyez une liste dans un ordre étrange.\nUn tri étrange consiste à commencer par la valeur minimale,\npuis la maximale des entiers restants, puis le minimum, et ainsi de suite.\n\nExemples:\nstrange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\nstrange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\nstrange_sort_list([]) == []\n'''\n", "entry_point": "strange_sort_list", "canonical_solution": "    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/134", "prompt": "\ndef check_if_last_char_is_a_letter(txt):\n    '''\n    Créez une fonction qui retourne True si le dernier caractère d'une chaîne donnée est un caractère alphabétique et ne fait pas partie d'un mot, et False sinon.\nRemarque : \"mot\" est un groupe de caractères séparés par un espace.\n\nExemples :\ncheck_if_last_char_is_a_letter(\"apple pie\") ➞ False\ncheck_if_last_char_is_a_letter(\"apple pi e\") ➞ True\ncheck_if_last_char_is_a_letter(\"apple pi e \") ➞ False\ncheck_if_last_char_is_a_letter(\"\") ➞ False'''\n", "entry_point": "check_if_last_char_is_a_letter", "canonical_solution": " \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n"}
{"task_id": "HumanEval/71", "prompt": "\ndef triangle_area(a, b, c):\n    '''\n    Étant donné les longueurs des trois côtés d'un triangle. Renvoyer la zone du triangle arrondie à 2 décimales si les trois côtés forment un triangle valide. Sinon, renvoyer -1. Trois côtés forment un triangle valide lorsque la somme de deux côtés est supérieure au troisième côté. Exemple : `triangle_area(3, 4, 5) == 6.00`, `triangle_area(1, 2, 10) == -1`'''\n", "entry_point": "triangle_area", "canonical_solution": "    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n"}
{"task_id": "HumanEval/77", "prompt": "\ndef iscube(a):\n    '''\n    Écrivez une fonction qui prend un entier a et renvoie True si cet entier est un cube d'un nombre entier.\nRemarque : vous pouvez supposer que l'entrée est toujours valide.\nExemples :\niscube(1) ==> True\niscube(2) ==> False\niscube(-1) ==> True\niscube(64) ==> True\niscube(0) ==> True\niscube(180) ==> False'''\n", "entry_point": "iscube", "canonical_solution": "    a = abs(a)\n    return int(round(a ** (1. / 3))) ** 3 == a\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n"}
{"task_id": "HumanEval/74", "prompt": "\ndef total_match(lst1, lst2):\n    '''\n    Écrivez une fonction qui accepte deux listes de chaînes et renvoie la liste qui a un nombre total de caractères dans toutes les chaînes de la liste inférieur à l'autre liste.\n\nSi les deux listes ont le même nombre de caractères, renvoyez la première liste.\n\nExemples\ntotal_match([], []) ➞ []\ntotal_match(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\ntotal_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\ntotal_match(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']'''\n", "entry_point": "total_match", "canonical_solution": "    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n"}
{"task_id": "HumanEval/92", "prompt": "\ndef any_int(x, y, z):\n    '''\n    Créez une fonction qui prend 3 nombres.\nRenvoie vrai si l'un des nombres est égal à la somme des deux autres, et tous les nombres sont des entiers.\nRenvoie faux dans tous les autres cas.\n\nExemples\nany_int(5, 2, 7) ➞ Vrai\n\nany_int(3, 2, 2) ➞ Faux\n\nany_int(3, -2, 1) ➞ Vrai\n\nany_int(3.6, -2.2, 2) ➞ Faux\n'''\n", "entry_point": "any_int", "canonical_solution": "    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n"}
{"task_id": "HumanEval/132", "prompt": "\ndef is_nested(string):\n    '''\n    Créez une fonction qui prend en entrée une chaîne de caractères contenant uniquement des crochets carrés. La fonction doit renvoyer True si et seulement si il y a une sous-séquence valide de crochets où au moins un crochet dans la sous-séquence est imbriqué.\n\nis_nested('[[]]') ➞ True\nis_nested('[]]]]]]][[[[[]') ➞ False\nis_nested('[][]') ➞ False\nis_nested('[]') ➞ False\nis_nested('[[][]]') ➞ True\nis_nested('[[]][[') ➞ True'''\n", "entry_point": "is_nested", "canonical_solution": "    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n"}
{"task_id": "HumanEval/151", "prompt": "\ndef double_the_difference(lst):\n    '''\n    Étant donné une liste de nombres, retournez la somme des carrés des nombres dans la liste qui sont impairs. Ignorez les nombres qui sont négatifs ou non entiers.\n\ndouble_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0  \n\nSi la liste d'entrée est vide, retournez 0.\n'''\n", "entry_point": "double_the_difference", "canonical_solution": "    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n"}
{"task_id": "HumanEval/125", "prompt": "\ndef split_words(txt):\n    '''\n    Étant donné une chaîne de mots, renvoie une liste de mots divisée par des espaces blancs, si aucun espace blanc n'existe dans le texte, vous devez diviser sur des virgules ',' si aucune virgule n'existe, vous devez renvoyer le nombre de lettres minuscules avec un ordre impair dans l'alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\nExemples\nsplit_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\nsplit_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\nsplit_words(\"abcdef\") == 3 \n'''\n", "entry_point": "split_words", "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n", "test": "def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n"}
{"task_id": "HumanEval/99", "prompt": "\ndef closest_integer(value):\n    '''\n    Créez une fonction qui prend une valeur (chaîne de caractères) représentant un nombre et renvoie l'entier le plus proche. Si le nombre est à égale distance de deux entiers, arrondissez-le loin de zéro.\n\nExemples\n>>> closest_integer(\"10\")\n10\n>>> closest_integer(\"15.3\")\n15\n\nRemarque :\nArrondir loin de zéro signifie que si le nombre donné est à égale distance de deux entiers, celui que vous devez renvoyer est celui qui est le plus éloigné de zéro. Par exemple, closest_integer(\"14.5\") doit renvoyer 15 et closest_integer(\"-14.5\") doit renvoyer -15.'''\n", "entry_point": "closest_integer", "canonical_solution": "    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n"}
{"task_id": "HumanEval/119", "prompt": "\ndef match_parens(lst):\n    '''\n    Vous avez donné une liste de deux chaînes de caractères, les deux chaînes ne contiennent que des parenthèses ouvrantes '(' ou des parenthèses fermantes ')' uniquement. Votre tâche est de vérifier s'il est possible de concaténer les deux chaînes dans un certain ordre, de sorte que la chaîne résultante soit valide. Une chaîne S est considérée comme valide si et seulement si toutes les parenthèses dans S sont équilibrées. Par exemple : la chaîne '(())()' est valide, tandis que la chaîne '())' ne l'est pas. Renvoyez 'Yes' s'il existe un moyen de créer une chaîne valide, et renvoyez 'No' sinon.\n\nExemples :\nmatch_parens(['()(', ')']) == 'Yes'\nmatch_parens([')', ')']) == 'No'''\n", "entry_point": "match_parens", "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n"}
{"task_id": "HumanEval/69", "prompt": "\ndef search(lst):\n    '''\n    Vous avez donné une liste non vide de nombres entiers positifs. Renvoyez le plus grand entier supérieur à zéro, et ayant une fréquence supérieure ou égale à la valeur de l'entier lui-même. La fréquence d'un entier est le nombre de fois qu'il apparaît dans la liste. Si aucune valeur de ce type n'existe, renvoyez -1. Exemples: search([4, 1, 2, 2, 3, 1]) == 2 search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3 search([5, 5, 4, 4, 4]) == -1'''\n", "entry_point": "search", "canonical_solution": "    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n", "test": "def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n"}
{"task_id": "HumanEval/148", "prompt": "\ndef bf(planet1, planet2):\n    '''\n    Il y a huit planètes dans notre système solaire: la plus proche du Soleil est Mercure, la suivante est Vénus, puis la Terre, Mars, Jupiter, Saturne, Uranus, Neptune.\nÉcrivez une fonction qui prend deux noms de planètes en tant que chaînes de caractères `planet1` et `planet2`. \nLa fonction doit renvoyer un tuple contenant toutes les planètes dont les orbites sont situées entre l'orbite de `planet1` et l'orbite de `planet2`, triées par proximité avec le soleil. \nLa fonction doit renvoyer un tuple vide si `planet1` ou `planet2` ne sont pas des noms de planètes corrects. \nExemples\n`bf(\"Jupiter\", \"Neptune\") ==> (\"Saturne\", \"Uranus\")`\n`bf(\"Terre\", \"Mercure\") ==> (\"Vénus\")`\n`bf(\"Mercure\", \"Uranus\") ==> (\"Vénus\", \"Terre\", \"Mars\", \"Jupiter\", \"Saturne\")`'''\n", "entry_point": "bf", "canonical_solution": "    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n"}
{"task_id": "HumanEval/72", "prompt": "\ndef will_it_fly(q,w):\n    '''\n    Écrivez une fonction qui renvoie Vrai si l'objet q volera, et Faux sinon.\nL'objet q volera s'il est équilibré (c'est une liste palindromique) et que la somme de ses éléments est inférieure ou égale au poids maximal possible w.\n\nExemple:\nwill_it_fly([1, 2], 5) ➞ Faux \n# 1+2 est inférieur au poids maximal possible, mais c'est déséquilibré.\n\nwill_it_fly([3, 2, 3], 1) ➞ Faux\n# c'est équilibré, mais 3+2+3 est plus que le poids maximal possible.\n\nwill_it_fly([3, 2, 3], 9) ➞ Vrai\n# 3+2+3 est moins que le poids maximal possible, et c'est équilibré.\n\nwill_it_fly([3], 5) ➞ Vrai\n# 3 est moins que le poids maximal possible, et c'est équilibré.'''\n", "entry_point": "will_it_fly", "canonical_solution": "    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n"}
{"task_id": "HumanEval/136", "prompt": "\ndef largest_smallest_integers(lst):\n    '''\n    Créez une fonction qui renvoie un tuple (a, b), où 'a' est le plus grand des entiers négatifs et 'b' est le plus petit des entiers positifs dans une liste.\nS'il n'y a pas d'entiers négatifs ou positifs, renvoyez-les comme None.\n\nExemples:\nlargest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\nlargest_smallest_integers([]) == (None, None)\nlargest_smallest_integers([0]) == (None, None)'''\n", "entry_point": "largest_smallest_integers", "canonical_solution": "    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n"}
{"task_id": "HumanEval/126", "prompt": "\ndef is_sorted(lst):\n    '''\n    Étant donné une liste de nombres, retournez s'ils sont triés par ordre croissant ou non. Si la liste a plus d'1 doublon du même nombre, retournez Faux. Supposons qu'il n'y a pas de nombres négatifs et uniquement des entiers.\n\nExemples\nis_sorted([5]) ➞ Vrai\nis_sorted([1, 2, 3, 4, 5]) ➞ Vrai\nis_sorted([1, 3, 2, 4, 5]) ➞ Faux\nis_sorted([1, 2, 3, 4, 5, 6]) ➞ Vrai\nis_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ Vrai\nis_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ Faux\nis_sorted([1, 2, 2, 3, 3, 4]) ➞ Vrai\nis_sorted([1, 2, 2, 2, 3, 4]) ➞ Faux'''\n", "entry_point": "is_sorted", "canonical_solution": "    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n"}
